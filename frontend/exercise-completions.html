<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Stretch Coach ‚Äì Fortschritt</title>
    <style>
      :root {
        color-scheme: light;
        --bg-gradient: linear-gradient(135deg, #7f7fd5, #86a8e7, #91eae4);
        --surface: rgba(255, 255, 255, 0.9);
        --surface-strong: rgba(255, 255, 255, 0.98);
        --text-primary: #1a2a3a;
        --text-secondary: #516170;
        --accent: #3d8bff;
        --accent-strong: #2f6ad8;
        --accent-soft: rgba(61, 139, 255, 0.08);
        --accent-border: rgba(61, 139, 255, 0.2);
        --radius-large: 24px;
        --shadow: 0 18px 32px rgba(26, 42, 58, 0.15);
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
          "Helvetica Neue", Arial, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        padding: clamp(1.5rem, 4vw, 3rem);
        background: var(--bg-gradient);
        color: var(--text-primary);
      }

      main {
        width: min(1080px, 100%);
        display: grid;
        gap: clamp(1.5rem, 3vw, 2.5rem);
      }

      .page-nav {
        display: flex;
        justify-content: flex-start;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.65rem 1.1rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: #fff;
        text-decoration: none;
        font-weight: 600;
        box-shadow: 0 10px 20px rgba(61, 139, 255, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .back-link:hover,
      .back-link:focus-visible {
        filter: brightness(1.05);
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(61, 139, 255, 0.32);
      }

      .card {
        background: var(--surface);
        border-radius: var(--radius-large);
        padding: clamp(1.5rem, 3vw, 2.5rem);
        box-shadow: var(--shadow);
        backdrop-filter: blur(8px);
      }

      header.card {
        display: grid;
        gap: 0.6rem;
        text-align: center;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 4vw, 2.6rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0;
        color: var(--text-secondary);
        font-size: 1rem;
      }

      .summary-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
        margin: 1rem 0 0;
      }

      .metrics-grid--compact {
        margin-top: 0.75rem;
      }

      .metric-tile {
        background: var(--surface-strong);
        border-radius: 16px;
        padding: 0.9rem 1rem;
        border: 1px solid rgba(61, 139, 255, 0.15);
        box-shadow: 0 10px 18px rgba(26, 42, 58, 0.1);
        display: grid;
        gap: 0.35rem;
      }

      .metric-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-secondary);
      }

      .metric-value {
        font-weight: 600;
        font-size: 1.4rem;
      }

      .summary-tile {
        background: var(--surface-strong);
        border-radius: 18px;
        padding: 1.1rem 1.3rem;
        border: 1px solid rgba(61, 139, 255, 0.15);
        box-shadow: 0 12px 22px rgba(26, 42, 58, 0.12);
        display: grid;
        gap: 0.3rem;
      }

      .summary-label {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-secondary);
      }

      .summary-value {
        font-weight: 700;
        font-size: clamp(1.6rem, 4vw, 2.2rem);
      }

      .summary-hint {
        margin: 0;
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      .section-title {
        margin: 0 0 0.6rem;
        font-size: 1.1rem;
        font-weight: 600;
      }

      .section-subtitle {
        margin: 1.6rem 0 0.6rem;
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text-secondary);
      }

      .list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.65rem;
      }

      .list-item {
        padding: 0.9rem 1rem;
        border-radius: 16px;
        background: var(--accent-soft);
        border: 1px solid var(--accent-border);
        display: flex;
        justify-content: space-between;
        gap: 1.5rem;
      }

      .list-item strong {
        font-weight: 600;
      }

      .table-card {
        overflow: hidden;
        padding: 0;
      }

      .chart-card {
        padding-bottom: 1.4rem;
      }

      .chart-header {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1rem;
      }

      .chart-header__title {
        display: grid;
        gap: 0.4rem;
      }

      @media (min-width: 640px) {
        .chart-header {
          flex-direction: row;
          align-items: flex-end;
          justify-content: space-between;
          gap: 1rem;
        }

        .chart-header__title {
          flex: 1;
        }
      }

      .chart-toggle {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem;
        border-radius: 999px;
        background: rgba(61, 139, 255, 0.08);
        box-shadow: inset 0 0 0 1px rgba(61, 139, 255, 0.15);
      }

      .chart-toggle__button {
        border: none;
        background: transparent;
        color: var(--text-secondary);
        font-weight: 600;
        font-size: 0.85rem;
        padding: 0.35rem 0.85rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .chart-toggle__button:hover,
      .chart-toggle__button:focus-visible {
        background: rgba(61, 139, 255, 0.14);
        color: var(--accent-strong);
        outline: none;
      }

      .chart-toggle__button--active {
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        color: #fff;
        box-shadow: 0 8px 18px rgba(61, 139, 255, 0.3);
      }

      .chart-hint {
        margin: 0;
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .chart-container {
        width: 100%;
        position: relative;
        min-height: 240px;
      }

      #weeklyChart {
        width: 100%;
        height: 260px;
        display: block;
      }

      #streakChart {
        width: 100%;
        height: 260px;
        display: block;
      }

      .chart-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        margin-bottom: 1rem;
      }

      .chart-legend__item {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: var(--text-secondary);
        background: rgba(61, 139, 255, 0.08);
        border-radius: 999px;
        padding: 0.35rem 0.7rem;
      }

      .chart-legend__swatch {
        width: 12px;
        height: 12px;
        border-radius: 999px;
      }

      .table-header {
        padding: 1.6rem 1.8rem 0.8rem;
      }

      .table-container {
        overflow-x: auto;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 640px;
      }

      thead {
        background: rgba(61, 139, 255, 0.1);
      }

      th,
      td {
        padding: 0.85rem 1rem;
        text-align: left;
        border-bottom: 1px solid rgba(26, 42, 58, 0.1);
        font-size: 0.9rem;
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      tbody tr:nth-child(odd) {
        background: rgba(61, 139, 255, 0.06);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: space-between;
        padding: 0 1.8rem 1.6rem;
      }

      button,
      a.button-link {
        font-size: 0.95rem;
        font-weight: 600;
        padding: 0.75rem 1.2rem;
        border-radius: 14px;
        border: none;
        cursor: pointer;
        color: #fff;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        box-shadow: 0 12px 22px rgba(61, 139, 255, 0.28);
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        transition: transform 0.2s ease, filter 0.2s ease;
      }

      button:hover,
      a.button-link:hover {
        transform: translateY(-1px);
        filter: brightness(1.05);
      }

      button:active,
      a.button-link:active {
        transform: translateY(0);
        filter: brightness(0.95);
      }

      button:disabled {
        opacity: 0.65;
        cursor: progress;
        box-shadow: none;
      }

      .status {
        margin-top: 1rem;
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.95rem;
      }

      .status[data-type="error"] {
        color: #a12315;
      }

      .status[data-type="empty"] {
        color: #8c5a05;
      }

      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .chip {
        padding: 0.4rem 0.8rem;
        border-radius: 999px;
        background: rgba(26, 42, 58, 0.08);
        font-size: 0.85rem;
      }

      footer {
        text-align: center;
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>
    <main>
      <nav class="page-nav">
        <a class="back-link" href="./index.html" aria-label="Zur√ºck zur Startseite">‚Üê Zur√ºck</a>
      </nav>
      <header class="card">
        <h1>üìà Trainingsfortschritt</h1>
        <p>Hier findest du alle aufgezeichneten Stretching-Einheiten und hilfreiche Statistiken.</p>
      </header>

      <section class="card">
        <div class="summary-grid">
          <div class="summary-tile">
            <span class="summary-label">√úbungen gesamt</span>
            <span class="summary-value" id="totalExercises">‚Äì</span>
            <p class="summary-hint">Abgeschlossene Einheiten ohne Testeintr√§ge.</p>
          </div>
          <div class="summary-tile">
            <span class="summary-label">Einzigartige √úbungen</span>
            <span class="summary-value" id="uniqueExercises">‚Äì</span>
            <p class="summary-hint" id="exerciseSummaryHint">Keine √úbungsdaten verf√ºgbar.</p>
          </div>
        </div>
      </section>

      <section class="card">
        <h2 class="section-title">Aktivit√§tsstatistiken</h2>
        <div class="metrics-grid" aria-label="√úbungsanzahl">
          <div class="metric-tile">
            <span class="metric-label">Heute</span>
            <span class="metric-value" id="exercisesToday">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Diese Woche</span>
            <span class="metric-value" id="exercisesWeek">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Diesen Monat</span>
            <span class="metric-value" id="exercisesMonth">‚Äì</span>
          </div>
        </div>
        <h3 class="section-subtitle">Trainingsdauer</h3>
        <div class="metrics-grid metrics-grid--compact" aria-label="Trainingsdauer">
          <div class="metric-tile">
            <span class="metric-label">Heute</span>
            <span class="metric-value" id="durationToday">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Diese Woche</span>
            <span class="metric-value" id="durationWeek">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Diesen Monat</span>
            <span class="metric-value" id="durationMonth">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Gesamt</span>
            <span class="metric-value" id="durationTotal">‚Äì</span>
          </div>
        </div>
      </section>

      <section class="card chart-card">
        <div class="chart-header">
          <div class="chart-header__title">
            <h2 class="section-title">Trainingsdauer</h2>
            <p class="chart-hint" id="weeklyChartHint">Trainingszeit dieser Woche nach Tagen.</p>
          </div>
          <div class="chart-toggle" role="group" aria-label="Zeitraum ausw√§hlen">
            <button
              type="button"
              class="chart-toggle__button chart-toggle__button--active"
              data-chart-mode="1w"
            >
              1&nbsp;W
            </button>
            <button type="button" class="chart-toggle__button" data-chart-mode="4w">
              4&nbsp;W
            </button>
            <button type="button" class="chart-toggle__button" data-chart-mode="6m">
              6&nbsp;M
            </button>
          </div>
        </div>
        <div class="chart-container">
          <canvas
            id="weeklyChart"
            role="img"
            aria-label="S√§ulendiagramm der Trainingszeit dieser Woche nach Tagen"
          ></canvas>
        </div>
        <p class="status" id="chartStatus" hidden></p>
      </section>

      <section class="card chart-card">
        <div class="chart-header">
          <h2 class="section-title">Streak-Entwicklung</h2>
          <p class="chart-hint">
            Ein Streak z√§hlt ab 20 Minuten Training pro Tag. Bis zu drei Pausentage in sieben Tagen
            bleiben ohne Unterbrechung.
          </p>
        </div>
        <div class="metrics-grid metrics-grid--compact" aria-label="Streak-Statistiken">
          <div class="metric-tile">
            <span class="metric-label">Aktueller Streak</span>
            <span class="metric-value" id="currentStreak">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Bester Streak</span>
            <span class="metric-value" id="bestStreak">‚Äì</span>
          </div>
          <div class="metric-tile">
            <span class="metric-label">Freie Pausentage (7-Tage-Fenster)</span>
            <span class="metric-value" id="streakAllowance">‚Äì</span>
          </div>
        </div>
        <p class="chart-hint" id="streakLastReset">Letzte Unterbrechung: ‚Äì</p>
        <div class="chart-legend">
          <span class="chart-legend__item">
            <span class="chart-legend__swatch" style="background: var(--accent);"></span>
            Training ‚â• 20&nbsp;Minuten
          </span>
          <span class="chart-legend__item">
            <span class="chart-legend__swatch" style="background: #f3a712;"></span>
            Genehmigter Pausentag (max. 3 in 7 Tagen)
          </span>
          <span class="chart-legend__item">
            <span class="chart-legend__swatch" style="background: #d64550;"></span>
            Streak zur√ºckgesetzt
          </span>
        </div>
        <div class="chart-container">
          <canvas
            id="streakChart"
            role="img"
            aria-label="Streak-Entwicklung der letzten Wochen"
          ></canvas>
        </div>
        <p class="status" id="streakStatus" hidden></p>
      </section>

      <section class="card">
        <h2 class="section-title">Top-√úbungen</h2>
        <ul class="list" id="topExercises"></ul>
        <p class="status" id="exerciseStatus" hidden></p>
      </section>

      <section class="card table-card">
        <div class="table-header">
          <h2 class="section-title">Alle Eintr√§ge</h2>
          <div class="chips" id="columnChips"></div>
        </div>
        <div class="table-container">
          <table aria-live="polite">
            <thead>
              <tr id="tableHeadRow"></tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
        <div class="actions">
          <button id="refreshBtn" type="button">Aktualisieren</button>
          <a class="button-link" href="./index.html">Zur√ºck zur App</a>
        </div>
        <p class="status" id="tableStatus"></p>
      </section>

      <footer>
        Stretch Coach ‚Äì Bleib flexibel und achtsam ‚ú®
      </footer>
    </main>

    <script src="./config.production.js"></script>
    <script>
      const appConfig = window.STRETCH_COACH_CONFIG || {};

      function stripTrailingSlash(value) {
        return value.replace(/\/+$/, "");
      }

      function determineProgressEndpoint(config) {
        if (config && typeof config.progressApiUrl === "string") {
          const trimmed = config.progressApiUrl.trim();
          if (!trimmed) {
            return "/api/exercise-completions";
          }
          const normalized = stripTrailingSlash(trimmed);
          return normalized || "/api/exercise-completions";
        }
        if (config && config.progressApiUrl === null) {
          return null;
        }
        if (config && typeof config.progressApiBaseUrl === "string") {
          const trimmedBase = config.progressApiBaseUrl.trim();
          if (!trimmedBase) {
            return "/api/exercise-completions";
          }
          const normalizedBase = stripTrailingSlash(trimmedBase);
          return normalizedBase
            ? `${normalizedBase}/api/exercise-completions`
            : "/api/exercise-completions";
        }
        return "/api/exercise-completions";
      }

      const API_URL = determineProgressEndpoint(appConfig);
      const refreshBtn = document.getElementById("refreshBtn");
      const totalExercisesEl = document.getElementById("totalExercises");
      const uniqueExercisesEl = document.getElementById("uniqueExercises");
      const topExercisesList = document.getElementById("topExercises");
      const exerciseSummaryHint = document.getElementById("exerciseSummaryHint");
      const exerciseStatus = document.getElementById("exerciseStatus");
      const exercisesTodayEl = document.getElementById("exercisesToday");
      const exercisesWeekEl = document.getElementById("exercisesWeek");
      const exercisesMonthEl = document.getElementById("exercisesMonth");
      const durationTodayEl = document.getElementById("durationToday");
      const durationWeekEl = document.getElementById("durationWeek");
      const durationMonthEl = document.getElementById("durationMonth");
      const durationTotalEl = document.getElementById("durationTotal");
      const columnChips = document.getElementById("columnChips");
      const tableHeadRow = document.getElementById("tableHeadRow");
      const tableBody = document.getElementById("tableBody");
      const tableStatus = document.getElementById("tableStatus");
      const weeklyChartCanvas = document.getElementById("weeklyChart");
      const chartStatus = document.getElementById("chartStatus");
      const chartHint = document.getElementById("weeklyChartHint");
      const chartModeButtons = document.querySelectorAll("[data-chart-mode]");
      const streakChartCanvas = document.getElementById("streakChart");
      const streakStatus = document.getElementById("streakStatus");
      const currentStreakEl = document.getElementById("currentStreak");
      const bestStreakEl = document.getElementById("bestStreak");
      const streakAllowanceEl = document.getElementById("streakAllowance");
      const streakLastResetEl = document.getElementById("streakLastReset");

      const TIME_KEYS = [
        "completedAt",
        "completed_at",
        "finishedAt",
        "finished_at",
        "timestamp",
        "createdAt",
        "updatedAt",
        "time",
        "date",
      ];
      const USER_KEYS = ["clientId", "userId", "participantId", "profileId"];
      const PRIORITY_COLUMNS = [
        "completedAt",
        "timestamp",
        "exerciseName",
        "exerciseId",
        "clientId",
        "duration",
        "count",
      ];

      let latestData = [];
      let currentWeeklyBuckets = [];
      let currentStreakTimeline = [];
      let currentDailyDurations = new Map();
      let currentChartMode = "1w";

      const numberFormatter = new Intl.NumberFormat("de-DE");
      const decimalFormatter = new Intl.NumberFormat("de-DE", {
        maximumFractionDigits: 1,
        minimumFractionDigits: 0,
      });
      const shortDateFormatter = new Intl.DateTimeFormat("de-DE", {
        day: "2-digit",
        month: "2-digit",
      });
      const chartDayFormatter = new Intl.DateTimeFormat("de-DE", {
        day: "2-digit",
        month: "2-digit",
      });
      const weekdayFormatter = new Intl.DateTimeFormat("de-DE", {
        weekday: "short",
      });
      const monthFormatter = new Intl.DateTimeFormat("de-DE", {
        month: "short",
      });

      const STREAK_THRESHOLD_SECONDS = 20 * 60;
      const STREAK_LOOKBACK_DAYS = 84;
      const STREAK_ROLLING_WINDOW_DAYS = 7;
      const STREAK_MIN_ACTIVE_DAYS = 4;
      const STREAK_MAX_SKIPS_PER_WINDOW = STREAK_ROLLING_WINDOW_DAYS - STREAK_MIN_ACTIVE_DAYS;

      function formatDate(value) {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return null;
        }
        return new Intl.DateTimeFormat("de-DE", {
          dateStyle: "medium",
          timeStyle: "short",
        }).format(date);
      }

      function formatValue(key, value) {
        if (value === null || value === undefined || value === "") {
          return "‚Äì";
        }

        if (typeof value === "number") {
          if (key.toLowerCase().includes("duration")) {
            const seconds = Math.round(value / 1000);
            return `${seconds}s`;
          }
          return new Intl.NumberFormat("de-DE").format(value);
        }

        if (typeof value === "string") {
          const lowerKey = key.toLowerCase();
          if (lowerKey.includes("time") || lowerKey.includes("date")) {
            const formatted = formatDate(value);
            if (formatted) {
              return formatted;
            }
          }
          if (/^https?:\/\//i.test(value)) {
            return `<a href="${value}" target="_blank" rel="noopener">Link</a>`;
          }
          return value;
        }

        if (value instanceof Date) {
          return formatDate(value);
        }

        if (typeof value === "object") {
          try {
            return JSON.stringify(value);
          } catch (_err) {
            return String(value);
          }
        }

        return String(value);
      }

      const EXERCISE_ID_KEYS = ["exerciseId", "exercise_id", "exercise"];
      const EXERCISE_NAME_KEYS = [
        "exerciseName",
        "exercise_name",
        "name",
        "title",
      ];
      const DURATION_KEYS = [
        "durationMs",
        "duration_ms",
        "durationMilliseconds",
        "duration_milliseconds",
        "duration",
        "durationSeconds",
        "duration_seconds",
      ];

      function formatNumber(value) {
        return numberFormatter.format(value);
      }

      function getFirstNonEmptyString(entry, keys) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        for (const key of keys) {
          const value = entry[key];
          if (value === null || value === undefined) {
            continue;
          }
          if (typeof value === "string") {
            const trimmed = value.trim();
            if (trimmed) {
              return trimmed;
            }
          } else if (typeof value === "number") {
            return String(value);
          }
        }
        return null;
      }

      function getExerciseId(entry) {
        const id = getFirstNonEmptyString(entry, EXERCISE_ID_KEYS);
        if (id) {
          return id;
        }
        const possible = entry?.exercise_id;
        if (possible !== undefined && possible !== null) {
          return String(possible);
        }
        return null;
      }

      function getExerciseName(entry) {
        const name = getFirstNonEmptyString(entry, EXERCISE_NAME_KEYS);
        if (name) {
          return name;
        }
        const id = getExerciseId(entry);
        if (id) {
          return id;
        }
        return "Unbekannte √úbung";
      }

      function escapeHtml(value) {
        return String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function isTestExercise(entry) {
        const id = getExerciseId(entry);
        if (!id) {
          return false;
        }
        const normalized = id.trim().toLowerCase();
        return normalized === "test" || normalized === "test √ºbung" || normalized === "test√ºbung";
      }

      function parseDateValue(value) {
        if (!value && value !== 0) {
          return null;
        }
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value;
        }
        if (typeof value === "number") {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date;
        }
        if (typeof value === "string") {
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }
          const date = new Date(trimmed);
          return Number.isNaN(date.getTime()) ? null : date;
        }
        return null;
      }

      function getCompletionDate(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }
        for (const key of TIME_KEYS) {
          if (entry[key]) {
            const parsed = parseDateValue(entry[key]);
            if (parsed) {
              return parsed;
            }
          }
        }
        if (entry.completed_at) {
          return parseDateValue(entry.completed_at);
        }
        if (entry.finished_at) {
          return parseDateValue(entry.finished_at);
        }
        return null;
      }

      function getStartOfDay(date) {
        const result = new Date(date);
        result.setHours(0, 0, 0, 0);
        return result;
      }

      function getStartOfWeek(date) {
        const result = getStartOfDay(date);
        const day = (result.getDay() + 6) % 7; // Montag als Wochenbeginn
        result.setDate(result.getDate() - day);
        return result;
      }

      function getStartOfMonth(date) {
        const result = getStartOfDay(date);
        result.setDate(1);
        return result;
      }

      function getIsoWeekInfo(date) {
        const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const day = temp.getUTCDay() || 7;
        temp.setUTCDate(temp.getUTCDate() + 4 - day);
        const yearStart = new Date(Date.UTC(temp.getUTCFullYear(), 0, 1));
        const weekNumber = Math.ceil(((temp - yearStart) / 86400000 + 1) / 7);
        return { week: weekNumber, year: temp.getUTCFullYear() };
      }

      function getDurationSeconds(entry) {
        if (!entry || typeof entry !== "object") {
          return 0;
        }
        for (const key of DURATION_KEYS) {
          if (!(key in entry)) {
            continue;
          }
          const value = entry[key];
          if (value === null || value === undefined) {
            continue;
          }
          if (typeof value === "number" && Number.isFinite(value)) {
            return key.toLowerCase().includes("ms") ? value / 1000 : value;
          }
          if (typeof value === "string") {
            const normalized = value.trim();
            if (!normalized) {
              continue;
            }
            const parsed = Number(normalized);
            if (Number.isFinite(parsed)) {
              return key.toLowerCase().includes("ms") ? parsed / 1000 : parsed;
            }
          }
        }
        return 0;
      }

      function formatDuration(totalSeconds) {
        const seconds = Math.max(0, Math.round(totalSeconds));
        if (!seconds) {
          return "0s";
        }
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = seconds % 60;
        const parts = [];
        if (hours) {
          parts.push(`${hours}h`);
        }
        if (minutes) {
          parts.push(`${minutes}m`);
        }
        if (!hours && (!minutes || hours === 0) && remainingSeconds) {
          parts.push(`${remainingSeconds}s`);
        } else if (!parts.length && remainingSeconds) {
          parts.push(`${remainingSeconds}s`);
        }
        return parts.join(" ") || "0s";
      }

      function formatMinutesLabel(value) {
        const minutes = Math.max(0, value);
        if (minutes >= 60) {
          const hours = minutes / 60;
          if (hours >= 10) {
            return `${formatNumber(Math.round(hours))}h`;
          }
          return `${decimalFormatter.format(hours)}h`;
        }
        return `${formatNumber(Math.round(minutes))}m`;
      }

      function getChartEmptyText(mode) {
        switch (mode) {
          case "4w":
            return "Keine Trainingszeit in den letzten vier abgeschlossenen Wochen erfasst.";
          case "6m":
            return "Keine Trainingszeit in den letzten sechs Monaten erfasst.";
          default:
            return "Keine Trainingszeit in dieser Woche erfasst.";
        }
      }

      function updateChartHint(mode) {
        if (chartHint) {
          let hintText = "";
          switch (mode) {
            case "4w":
              hintText = "Trainingszeit der letzten vier abgeschlossenen Wochen.";
              break;
            case "6m":
              hintText = "Trainingszeit der letzten sechs Monate.";
              break;
            default:
              hintText = "Trainingszeit dieser Woche nach Tagen.";
              break;
          }
          chartHint.textContent = hintText;
        }

        if (weeklyChartCanvas) {
          let ariaLabel = "";
          switch (mode) {
            case "4w":
              ariaLabel =
                "S√§ulendiagramm der Trainingszeit der letzten vier abgeschlossenen Wochen";
              break;
            case "6m":
              ariaLabel = "S√§ulendiagramm der Trainingszeit der letzten sechs Monate";
              break;
            default:
              ariaLabel = "S√§ulendiagramm der Trainingszeit dieser Woche nach Tagen";
              break;
          }
          weeklyChartCanvas.setAttribute("aria-label", ariaLabel);
        }
      }

      function sumDurationsInRange(dailyDurations, start, end) {
        if (!(dailyDurations instanceof Map)) {
          return 0;
        }
        const cursor = getStartOfDay(start);
        const limit = getStartOfDay(end);
        let total = 0;
        while (cursor < limit) {
          const key = cursor.toISOString().slice(0, 10);
          total += dailyDurations.get(key) || 0;
          cursor.setDate(cursor.getDate() + 1);
        }
        return total;
      }

      function buildDurationBuckets(dailyDurations, mode) {
        const map = dailyDurations instanceof Map ? dailyDurations : new Map();
        const today = getStartOfDay(new Date());
        const buckets = [];

        if (mode === "4w") {
          const currentWeekStart = getStartOfWeek(today);
          for (let offset = 4; offset >= 1; offset -= 1) {
            const start = new Date(currentWeekStart);
            start.setDate(start.getDate() - offset * 7);
            const end = new Date(start);
            end.setDate(end.getDate() + 7);
            const totalSeconds = sumDurationsInRange(map, start, end);
            const { week } = getIsoWeekInfo(start);
            buckets.push({
              start,
              end,
              totalSeconds,
              labelLines: [
                `KW ${String(week).padStart(2, "0")}`,
                shortDateFormatter.format(start),
              ],
            });
          }
          return buckets;
        }

        if (mode === "6m") {
          const currentMonthStart = getStartOfMonth(today);
          for (let offset = 5; offset >= 0; offset -= 1) {
            const start = new Date(currentMonthStart);
            start.setMonth(start.getMonth() - offset);
            const end = new Date(start);
            end.setMonth(end.getMonth() + 1);
            const totalSeconds = sumDurationsInRange(map, start, end);
            buckets.push({
              start,
              end,
              totalSeconds,
              labelLines: [monthFormatter.format(start), String(start.getFullYear())],
            });
          }
          return buckets;
        }

        const weekStart = getStartOfWeek(today);
        for (let index = 0; index < 7; index += 1) {
          const start = new Date(weekStart);
          start.setDate(weekStart.getDate() + index);
          const end = new Date(start);
          end.setDate(end.getDate() + 1);
          const totalSeconds = sumDurationsInRange(map, start, end);
          buckets.push({
            start,
            end,
            totalSeconds,
            labelLines: [weekdayFormatter.format(start), shortDateFormatter.format(start)],
          });
        }
        return buckets;
      }

      function refreshDurationChart() {
        if (!weeklyChartCanvas) {
          return;
        }
        currentWeeklyBuckets = buildDurationBuckets(currentDailyDurations, currentChartMode);
        const hasData = currentWeeklyBuckets.some(bucket => bucket.totalSeconds > 0);
        if (chartStatus) {
          if (!hasData) {
            chartStatus.hidden = false;
            chartStatus.dataset.type = "empty";
            chartStatus.textContent = getChartEmptyText(currentChartMode);
          } else {
            chartStatus.hidden = true;
            delete chartStatus.dataset.type;
          }
        }
        renderWeeklyChart(currentWeeklyBuckets);
      }

      function renderWeeklyChart(buckets) {
        if (!weeklyChartCanvas) {
          return;
        }
        const ctx = weeklyChartCanvas.getContext("2d");
        if (!ctx) {
          return;
        }

        const devicePixelRatio = window.devicePixelRatio || 1;
        const cssWidth =
          weeklyChartCanvas.clientWidth || weeklyChartCanvas.offsetWidth || 600;
        const cssHeight = weeklyChartCanvas.clientHeight || 260;
        const width = cssWidth * devicePixelRatio;
        const height = cssHeight * devicePixelRatio;
        weeklyChartCanvas.width = Math.max(1, Math.floor(width));
        weeklyChartCanvas.height = Math.max(1, Math.floor(height));
        ctx.save();
        ctx.scale(devicePixelRatio, devicePixelRatio);

        const chartWidth = cssWidth;
        const chartHeight = cssHeight;
        const padding = { top: 24, right: 32, bottom: 56, left: 48 };
        const innerWidth = chartWidth - padding.left - padding.right;
        const innerHeight = chartHeight - padding.top - padding.bottom;
        const minutes = buckets.map(bucket => bucket.totalSeconds / 60);
        const maxValue = Math.max(...minutes, 0);
        const safeMax = maxValue <= 0 ? 1 : maxValue;

        ctx.clearRect(0, 0, chartWidth, chartHeight);
        ctx.font = "12px 'Inter', 'Segoe UI', system-ui";
        ctx.textBaseline = "alphabetic";

        ctx.strokeStyle = "rgba(61, 139, 255, 0.22)";
        ctx.lineWidth = 1;
        ctx.fillStyle = "rgba(26, 42, 58, 0.6)";
        const gridLines = 4;
        for (let i = 0; i <= gridLines; i += 1) {
          const ratio = i / gridLines;
          const y = padding.top + innerHeight - ratio * innerHeight;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + innerWidth, y);
          ctx.stroke();
          const rawValue = (safeMax / gridLines) * i;
          const value = i === gridLines ? safeMax : rawValue;
          ctx.fillText(formatMinutesLabel(value), 8, y + 4);
        }

        ctx.strokeStyle = "rgba(26, 42, 58, 0.12)";
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top + innerHeight + 0.5);
        ctx.lineTo(padding.left + innerWidth, padding.top + innerHeight + 0.5);
        ctx.stroke();

        const groupCount = Math.max(1, buckets.length);
        const groupWidth = innerWidth / groupCount;
        const maxBarWidth = Math.min(48, groupWidth * 0.6);
        const barGradient = ctx.createLinearGradient(
          0,
          padding.top,
          0,
          padding.top + innerHeight,
        );
        barGradient.addColorStop(0, "rgba(61, 139, 255, 0.92)");
        barGradient.addColorStop(1, "rgba(61, 139, 255, 0.55)");
        ctx.fillStyle = barGradient;

        buckets.forEach((bucket, index) => {
          const minutesValue = bucket.totalSeconds / 60;
          const barHeight = (minutesValue / safeMax) * innerHeight;
          if (barHeight <= 0) {
            return;
          }
          const availableWidth = Math.max(10, groupWidth * 0.8);
          const barWidth = Math.min(maxBarWidth, availableWidth);
          const barX = padding.left + groupWidth * index + (groupWidth - barWidth) / 2;
          const barY = padding.top + innerHeight - barHeight;
          const radius = Math.min(12, barWidth / 2, barHeight);

          if (typeof ctx.roundRect === "function") {
            ctx.beginPath();
            ctx.roundRect(barX, barY, barWidth, barHeight, radius > 0 ? radius : 0);
            ctx.fill();
          } else {
            ctx.fillRect(barX, barY, barWidth, barHeight);
          }
        });

        ctx.fillStyle = "rgba(26, 42, 58, 0.7)";
        buckets.forEach((bucket, index) => {
          const lines = bucket.labelLines || (bucket.label ? bucket.label.split("\n") : []);
          if (!lines.length) {
            return;
          }
          const xCenter = padding.left + groupWidth * index + groupWidth / 2;
          lines.forEach((line, lineIndex) => {
            if (!line) {
              return;
            }
            const textWidth = ctx.measureText(line).width;
            const maxX = padding.left + innerWidth - textWidth;
            const minX = padding.left;
            const textX = Math.min(maxX, Math.max(minX, xCenter - textWidth / 2));
            const textY = chartHeight - padding.bottom + 18 + lineIndex * 14;
            ctx.fillText(line, textX, textY);
          });
        });

        ctx.restore();
      }

      chartModeButtons.forEach(button => {
        if (!(button instanceof HTMLElement)) {
          return;
        }
        const mode = button.dataset.chartMode;
        const isActive = mode === currentChartMode;
        button.classList.toggle("chart-toggle__button--active", isActive);
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
        button.addEventListener("click", () => {
          const selectedMode = button.dataset.chartMode;
          if (!selectedMode || selectedMode === currentChartMode) {
            return;
          }
          currentChartMode = selectedMode;
          chartModeButtons.forEach(otherButton => {
            if (!(otherButton instanceof HTMLElement)) {
              return;
            }
            const otherMode = otherButton.dataset.chartMode;
            const active = otherMode === currentChartMode;
            otherButton.classList.toggle("chart-toggle__button--active", active);
            otherButton.setAttribute("aria-pressed", active ? "true" : "false");
          });
          updateChartHint(currentChartMode);
          refreshDurationChart();
        });
      });
      updateChartHint(currentChartMode);

      function buildDailyDurationMap(entries) {
        const dailyDurations = new Map();
        let earliestDate = null;
        for (const entry of entries) {
          const completedAt = getCompletionDate(entry);
          if (!completedAt) {
            continue;
          }
          const durationSeconds = getDurationSeconds(entry);
          if (durationSeconds <= 0) {
            continue;
          }
          const day = getStartOfDay(completedAt);
          if (!earliestDate || day < earliestDate) {
            earliestDate = day;
          }
          const key = day.toISOString().slice(0, 10);
          const existing = dailyDurations.get(key) || 0;
          dailyDurations.set(key, existing + durationSeconds);
        }
        return { dailyDurations, earliestDate };
      }

      function buildStreakTimeline(entries) {
        const { dailyDurations, earliestDate } = buildDailyDurationMap(entries);
        const today = getStartOfDay(new Date());
        const startDate = earliestDate ? getStartOfDay(earliestDate) : new Date(today);
        const totalDays = Math.max(1, Math.floor((today - startDate) / 86400000) + 1);

        const timeline = [];
        let currentStreak = 0;
        let bestStreak = 0;
        let lastResetDate = null;

        const windowStatuses = [];
        let trainingDaysInWindow = 0;
        let restDaysInWindow = 0;

        for (let offset = 0; offset < totalDays; offset += 1) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() + offset);

          const key = date.toISOString().slice(0, 10);
          const durationSeconds = dailyDurations.get(key) || 0;
          const isSuccess = durationSeconds >= STREAK_THRESHOLD_SECONDS;

          const isToday = date.getTime() === today.getTime();
          const isPending = isToday && !isSuccess;
          const windowStatus = isSuccess ? "success" : isPending ? "pending" : "rest";

          windowStatuses.push({ status: windowStatus, date: new Date(date) });
          if (windowStatus === "success") {
            trainingDaysInWindow += 1;
          } else if (windowStatus === "rest") {
            restDaysInWindow += 1;
          }

          while (windowStatuses.length > STREAK_ROLLING_WINDOW_DAYS) {
            const removed = windowStatuses.shift();
            if (removed?.status === "success") {
              trainingDaysInWindow -= 1;
            } else if (removed?.status === "rest") {
              restDaysInWindow -= 1;
            }
          }

          let status = "tolerated";
          if (windowStatus === "success") {
            status = "success";
          } else if (windowStatus === "pending") {
            status = "pending";
          }

          if (windowStatus !== "pending" && restDaysInWindow > STREAK_MAX_SKIPS_PER_WINDOW) {
            lastResetDate = new Date(date);
            if (windowStatus === "success") {
              currentStreak = 1;
              windowStatuses.length = 0;
              windowStatuses.push({ status: "success", date: new Date(date) });
              trainingDaysInWindow = 1;
              restDaysInWindow = 0;
            } else {
              currentStreak = 0;
              status = "reset";
              windowStatuses.length = 0;
              windowStatuses.push({ status: "rest", date: new Date(date) });
              trainingDaysInWindow = 0;
              restDaysInWindow = 1;
            }
          } else if (windowStatus === "success") {
            currentStreak += 1;
          }

          bestStreak = Math.max(bestStreak, currentStreak);

          timeline.push({
            date: new Date(date),
            durationSeconds,
            streak: currentStreak,
            status,
          });
        }

        const restDaysForAllowance = windowStatuses.filter(
          entry => entry.status === "rest" && entry.date.getTime() !== today.getTime(),
        ).length;

        const rawAllowedSkips = Math.max(
          0,
          STREAK_MAX_SKIPS_PER_WINDOW - restDaysForAllowance,
        );
        const trimmedTimeline = timeline.slice(-Math.min(STREAK_LOOKBACK_DAYS, timeline.length));
        const hasSuccessfulDay = timeline.some(point => point.status === "success");
        const allowedSkipsRemaining = hasSuccessfulDay
          ? rawAllowedSkips
          : STREAK_MAX_SKIPS_PER_WINDOW;

        return {
          timeline: trimmedTimeline,
          currentStreak,
          bestStreak,
          allowedSkipsRemaining,
          lastResetDate,
          hasSuccessfulDay,
        };
      }

      function renderStreakChart(timeline) {
        if (!streakChartCanvas) {
          return;
        }
        const ctx = streakChartCanvas.getContext("2d");
        if (!ctx) {
          return;
        }

        const devicePixelRatio = window.devicePixelRatio || 1;
        const cssWidth = streakChartCanvas.clientWidth || streakChartCanvas.offsetWidth || 600;
        const cssHeight = streakChartCanvas.clientHeight || 260;
        const width = cssWidth * devicePixelRatio;
        const height = cssHeight * devicePixelRatio;
        streakChartCanvas.width = Math.max(1, Math.floor(width));
        streakChartCanvas.height = Math.max(1, Math.floor(height));
        ctx.save();
        ctx.scale(devicePixelRatio, devicePixelRatio);

        const padding = { top: 20, right: 24, bottom: 60, left: 48 };
        const innerWidth = cssWidth - padding.left - padding.right;
        const innerHeight = cssHeight - padding.top - padding.bottom;

        ctx.clearRect(0, 0, cssWidth, cssHeight);
        ctx.font = "12px 'Inter', 'Segoe UI', system-ui";
        ctx.fillStyle = "rgba(26, 42, 58, 0.6)";
        ctx.strokeStyle = "rgba(61, 139, 255, 0.3)";
        ctx.lineWidth = 1;

        const streakValues = timeline.map(point => point.streak);
        const maxValue = Math.max(...streakValues, 0);
        const safeMax = maxValue <= 0 ? 1 : maxValue;

        const gridLines = 5;
        for (let i = 0; i <= gridLines; i += 1) {
          const ratio = i / gridLines;
          const y = padding.top + innerHeight - ratio * innerHeight;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + innerWidth, y);
          ctx.stroke();
          const rawValue = (safeMax / gridLines) * i;
          const value = i === gridLines ? safeMax : rawValue;
          ctx.fillText(formatNumber(Math.round(value)), 8, y + 4);
        }

        if (!timeline.length) {
          ctx.restore();
          return;
        }

        const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + innerHeight);
        gradient.addColorStop(0, "rgba(61, 139, 255, 0.25)");
        gradient.addColorStop(1, "rgba(61, 139, 255, 0)");

        ctx.beginPath();
        timeline.forEach((point, index) => {
          const x = padding.left + (innerWidth * index) / Math.max(1, timeline.length - 1);
          const y =
            padding.top + innerHeight - (point.streak / safeMax) * innerHeight;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.lineTo(padding.left + innerWidth, padding.top + innerHeight);
        ctx.lineTo(padding.left, padding.top + innerHeight);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.strokeStyle = "rgba(61, 139, 255, 0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        timeline.forEach((point, index) => {
          const x = padding.left + (innerWidth * index) / Math.max(1, timeline.length - 1);
          const y =
            padding.top + innerHeight - (point.streak / safeMax) * innerHeight;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        const pointColors = {
          success: "rgba(61, 139, 255, 0.95)",
          tolerated: "#f3a712",
          reset: "#d64550",
          pending: "#9aa0b1",
        };

        timeline.forEach((point, index) => {
          const x = padding.left + (innerWidth * index) / Math.max(1, timeline.length - 1);
          const y =
            padding.top + innerHeight - (point.streak / safeMax) * innerHeight;
          const color = pointColors[point.status] || "rgba(26, 42, 58, 0.6)";
          ctx.fillStyle = color;
          ctx.beginPath();
          const radius = point.status === "reset" ? 4.5 : 3.5;
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.fillStyle = "rgba(26, 42, 58, 0.7)";
        const labelInterval = Math.max(1, Math.floor(timeline.length / 6));
        timeline.forEach((point, index) => {
          if (index % labelInterval !== 0 && index !== timeline.length - 1) {
            return;
          }
          const x = padding.left + (innerWidth * index) / Math.max(1, timeline.length - 1);
          const label = chartDayFormatter.format(point.date);
          const textWidth = ctx.measureText(label).width;
          const clampedX = Math.min(
            padding.left + innerWidth - textWidth / 2,
            Math.max(padding.left, x - textWidth / 2),
          );
          ctx.fillText(label, clampedX, cssHeight - padding.bottom + 32);
        });

        ctx.restore();
      }

      function updateStreakStats(entries) {
        const {
          timeline,
          currentStreak,
          bestStreak,
          allowedSkipsRemaining,
          lastResetDate,
          hasSuccessfulDay,
        } = buildStreakTimeline(entries);

        currentStreakTimeline = timeline;
        currentStreakEl.textContent = formatNumber(currentStreak);
        bestStreakEl.textContent = formatNumber(bestStreak);
        streakAllowanceEl.textContent = formatNumber(allowedSkipsRemaining);

        if (lastResetDate) {
          const formatted = new Intl.DateTimeFormat("de-DE", {
            dateStyle: "medium",
          }).format(lastResetDate);
          streakLastResetEl.textContent = `Letzte Unterbrechung: ${formatted}`;
        } else if (hasSuccessfulDay) {
          streakLastResetEl.textContent = "Letzte Unterbrechung: keine innerhalb des Zeitraums.";
        } else {
          streakLastResetEl.textContent = "Letzte Unterbrechung: ‚Äì";
        }

        if (!timeline.length || !hasSuccessfulDay) {
          streakStatus.hidden = false;
          streakStatus.dataset.type = hasSuccessfulDay ? "info" : "empty";
          streakStatus.textContent = hasSuccessfulDay
            ? "Streak-Daten werden aufgebaut."
            : "Noch keine Trainingstage mit mindestens 20 Minuten vorhanden.";
        } else {
          streakStatus.hidden = true;
          delete streakStatus.dataset.type;
        }

        renderStreakChart(timeline);
      }

      function updateWeeklyChart(entries) {
        if (!weeklyChartCanvas) {
          return;
        }
        const { dailyDurations } = buildDailyDurationMap(entries);
        currentDailyDurations = dailyDurations;
        updateChartHint(currentChartMode);
        refreshDurationChart();
      }

      function updateActivityStats(entries) {
        const today = getStartOfDay(new Date());
        const weekStart = getStartOfWeek(new Date());
        const monthStart = getStartOfMonth(new Date());

        const stats = {
          today: { count: 0, duration: 0 },
          week: { count: 0, duration: 0 },
          month: { count: 0, duration: 0 },
          totalDuration: 0,
        };

        for (const entry of entries) {
          const finishedAt = getCompletionDate(entry);
          const durationSeconds = getDurationSeconds(entry);

          if (durationSeconds > 0) {
            stats.totalDuration += durationSeconds;
          }

          if (!finishedAt) {
            continue;
          }

          if (finishedAt >= today) {
            stats.today.count += 1;
            if (durationSeconds > 0) {
              stats.today.duration += durationSeconds;
            }
          }

          if (finishedAt >= weekStart) {
            stats.week.count += 1;
            if (durationSeconds > 0) {
              stats.week.duration += durationSeconds;
            }
          }

          if (finishedAt >= monthStart) {
            stats.month.count += 1;
            if (durationSeconds > 0) {
              stats.month.duration += durationSeconds;
            }
          }

        }

        exercisesTodayEl.textContent = formatNumber(stats.today.count);
        exercisesWeekEl.textContent = formatNumber(stats.week.count);
        exercisesMonthEl.textContent = formatNumber(stats.month.count);

        durationTodayEl.textContent = formatDuration(stats.today.duration);
        durationWeekEl.textContent = formatDuration(stats.week.duration);
        durationMonthEl.textContent = formatDuration(stats.month.duration);
        durationTotalEl.textContent = formatDuration(stats.totalDuration);
      }

      function determineUserKey(entries) {
        for (const key of USER_KEYS) {
          if (entries.some(entry => entry && entry[key])) {
            return key;
          }
        }
        return null;
      }

      function deriveColumns(entries) {
        const set = new Set();
        entries.forEach(entry => {
          if (!entry || typeof entry !== "object") return;
          Object.keys(entry).forEach(key => set.add(key));
        });

        const prioritized = PRIORITY_COLUMNS.filter(key => set.has(key));
        const remaining = Array.from(set).filter(key => !PRIORITY_COLUMNS.includes(key));
        remaining.sort((a, b) => a.localeCompare(b, "de"));
        return [...prioritized, ...remaining];
      }

      function updateSummary(filteredEntries, allEntries) {
        totalExercisesEl.textContent = formatNumber(filteredEntries.length);

        const exerciseStats = new Map();
        for (const entry of filteredEntries) {
          if (!entry || typeof entry !== "object") {
            continue;
          }
          const id = getExerciseId(entry);
          if (!id) {
            continue;
          }
          const name = getExerciseName(entry);
          const current = exerciseStats.get(id);
          if (current) {
            current.count += 1;
            if (!current.name || current.name === current.id) {
              current.name = name;
            }
          } else {
            exerciseStats.set(id, { id, name, count: 1 });
          }
        }

        const userKey = determineUserKey(filteredEntries);

        if (!exerciseStats.size) {
          uniqueExercisesEl.textContent = "0";
          exerciseSummaryHint.textContent = "Keine √úbungsdaten verf√ºgbar.";
          topExercisesList.innerHTML = "";
          exerciseStatus.hidden = false;
          exerciseStatus.dataset.type = "empty";
          if (allEntries.length && allEntries.every(isTestExercise)) {
            exerciseStatus.textContent =
              "Nur Testeintr√§ge vorhanden. Diese werden aus den Statistiken herausgefiltert.";
          } else if (allEntries.length) {
            exerciseStatus.textContent = "Keine g√ºltigen √úbungsdaten gefunden.";
          } else {
            exerciseStatus.textContent = "Keine Eintr√§ge vorhanden.";
          }
          return;
        }

        uniqueExercisesEl.textContent = formatNumber(exerciseStats.size);
        let hint = "Erfasste √úbungen anhand ihrer IDs (Testeintr√§ge ausgeschlossen).";

        if (userKey) {
          const users = new Set();
          for (const entry of filteredEntries) {
            if (!entry || typeof entry !== "object") {
              continue;
            }
            const identifier = entry[userKey];
            if (identifier !== undefined && identifier !== null && identifier !== "") {
              users.add(identifier);
            }
          }
          if (users.size > 0) {
            hint += ` ¬∑ ${formatNumber(users.size)} Teilnehmende (\"${userKey}\").`;
          }
        }

        exerciseSummaryHint.textContent = hint;

        const topEntries = Array.from(exerciseStats.values())
          .sort((a, b) => b.count - a.count)
          .slice(0, 10);

        topExercisesList.innerHTML = topEntries
          .map(item => {
            const titleAttr = escapeHtml(`ID: ${item.id}`);
            return `<li class="list-item" title="${titleAttr}"><strong>${escapeHtml(
              item.name,
            )}</strong><span>${formatNumber(item.count)}√ó</span></li>`;
          })
          .join("");

        exerciseStatus.hidden = true;
        delete exerciseStatus.dataset.type;
      }

      function updateTable(entries) {
        const columns = deriveColumns(entries);

        if (!columns.length) {
          tableHeadRow.innerHTML = "";
          tableBody.innerHTML = "";
          tableStatus.textContent = "Keine Daten zum Anzeigen.";
          tableStatus.dataset.type = "empty";
          return;
        }

        tableHeadRow.innerHTML = columns.map(column => `<th scope="col">${column}</th>`).join("");

        tableBody.innerHTML = entries
          .map(entry => {
            if (!entry || typeof entry !== "object") {
              return `<tr><td colspan="${columns.length}">‚Äì</td></tr>`;
            }
            const cells = columns
              .map(column => `<td>${formatValue(column, entry[column])}</td>`)
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");

        columnChips.innerHTML = columns
          .map(column => `<span class="chip">${column}</span>`)
          .join("");

        tableStatus.textContent = `${entries.length} Eintr√§ge angezeigt.`;
        delete tableStatus.dataset.type;
      }

      function ensureApiConfigured() {
        if (API_URL) {
          return true;
        }

        tableStatus.textContent = "Abruf der √úbungsdaten ist deaktiviert.";
        tableStatus.dataset.type = "error";
        exerciseStatus.hidden = false;
        exerciseStatus.dataset.type = "error";
        exerciseStatus.textContent =
          "Kein API-Endpunkt f√ºr √úbungsstatistiken konfiguriert.";
        chartStatus.hidden = false;
        chartStatus.dataset.type = "error";
        chartStatus.textContent =
          "Kein API-Endpunkt f√ºr √úbungsstatistiken konfiguriert.";
        streakStatus.hidden = false;
        streakStatus.dataset.type = "error";
        streakStatus.textContent =
          "Kein API-Endpunkt f√ºr √úbungsstatistiken konfiguriert.";
        currentStreakEl.textContent = "‚Äì";
        bestStreakEl.textContent = "‚Äì";
        streakAllowanceEl.textContent = "‚Äì";
        streakLastResetEl.textContent = "Letzte Unterbrechung: ‚Äì";
        if (weeklyChartCanvas) {
          const context = weeklyChartCanvas.getContext("2d");
          if (context) {
            context.clearRect(0, 0, weeklyChartCanvas.width, weeklyChartCanvas.height);
          }
        }
        if (streakChartCanvas) {
          const context = streakChartCanvas.getContext("2d");
          if (context) {
            context.clearRect(0, 0, streakChartCanvas.width, streakChartCanvas.height);
          }
        }
        refreshBtn.disabled = true;
        return false;
      }

      async function fetchData(signal) {
        if (!API_URL) {
          throw new Error("API-Endpunkt nicht konfiguriert.");
        }
        const response = await fetch(API_URL, { signal });
        if (!response.ok) {
          throw new Error(`API-Fehler (${response.status})`);
        }
        const data = await response.json();
        if (Array.isArray(data)) {
          return data;
        }
        if (data && Array.isArray(data.items)) {
          return data.items;
        }
        return data ? [data] : [];
      }

      async function loadData() {
        if (!ensureApiConfigured()) {
          return;
        }

        refreshBtn.disabled = true;
        tableStatus.textContent = "Lade Daten...";
        tableStatus.dataset.type = "info";
        exerciseStatus.hidden = true;
        chartStatus.hidden = true;
        delete chartStatus.dataset.type;

        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 20000);
          const data = await fetchData(controller.signal);
          clearTimeout(timeout);
          latestData = data;

          const filteredData = data.filter(entry => !isTestExercise(entry));

          updateSummary(filteredData, data);
          updateActivityStats(filteredData);
          updateWeeklyChart(filteredData);
          updateStreakStats(filteredData);
          updateTable(data);

          if (!data.length) {
            chartStatus.hidden = false;
            chartStatus.dataset.type = "empty";
            chartStatus.textContent = "Keine Eintr√§ge vorhanden.";
            return;
          }

          const filteredOut = data.length - filteredData.length;
          if (filteredOut > 0) {
            tableStatus.textContent = `${formatNumber(
              data.length,
            )} Eintr√§ge angezeigt (inkl. ${formatNumber(filteredOut)} Testeintr√§gen).`;
          } else {
            tableStatus.textContent = `${formatNumber(data.length)} Eintr√§ge angezeigt.`;
          }
          delete tableStatus.dataset.type;
        } catch (error) {
          tableStatus.textContent = error?.message || "Unbekannter Fehler beim Laden.";
          tableStatus.dataset.type = "error";
          exerciseStatus.hidden = false;
          exerciseStatus.dataset.type = "error";
          exerciseStatus.textContent = "Statistiken konnten nicht geladen werden.";
          chartStatus.hidden = false;
          chartStatus.dataset.type = "error";
          chartStatus.textContent = "Diagramm konnte nicht geladen werden.";
          streakStatus.hidden = false;
          streakStatus.dataset.type = "error";
          streakStatus.textContent = "Streak-Statistiken konnten nicht geladen werden.";
          currentStreakEl.textContent = "‚Äì";
          bestStreakEl.textContent = "‚Äì";
          streakAllowanceEl.textContent = "‚Äì";
          streakLastResetEl.textContent = "Letzte Unterbrechung: ‚Äì";
          if (streakChartCanvas) {
            const context = streakChartCanvas.getContext("2d");
            if (context) {
              context.clearRect(0, 0, streakChartCanvas.width, streakChartCanvas.height);
            }
          }
          console.error(error);
        } finally {
          refreshBtn.disabled = false;
        }
      }

      refreshBtn.addEventListener("click", () => {
        loadData();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && latestData.length) {
          loadData();
        }
      });

      window.addEventListener("resize", () => {
        renderWeeklyChart(currentWeeklyBuckets);
        renderStreakChart(currentStreakTimeline);
      });

      if (API_URL) {
        loadData();
      } else {
        ensureApiConfigured();
      }
    </script>
  </body>
</html>
