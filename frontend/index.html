<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#3d8bff" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <title>Stretch Buddy</title>
  <style>
    :root {
      color-scheme: light;
      --bg-gradient: linear-gradient(135deg, #7f7fd5, #86a8e7, #91eae4);
      --surface: rgba(255, 255, 255, 0.9);
      --text-primary: #1a2a3a;
      --text-secondary: #516170;
      --accent: #3d8bff;
      --accent-strong: #2f6ad8;
      --accent-warn: #f39c12;
      --accent-stop: #e74c3c;
      --radius-large: 24px;
      --shadow: 0 20px 40px rgba(26, 42, 58, 0.18);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
        "Helvetica Neue", Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    [hidden] {
      display: none !important;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4vw 5vw;
      background: var(--bg-gradient);
      color: var(--text-primary);
    }

    .app-card {
      width: min(440px, 100%);
      padding: clamp(1.8rem, 4vw, 2.6rem);
      background: var(--surface);
      backdrop-filter: blur(10px);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow);
      display: grid;
      gap: clamp(1rem, 2.5vw, 1.6rem);
    }

    header {
      text-align: center;
      display: grid;
      gap: 0.4rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 4vw, 2.4rem);
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    .input-group {
      display: grid;
      gap: 0.6rem;
    }

    .group-label {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .group-hint {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    select {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border-radius: 16px;
      border: 1px solid rgba(61, 139, 255, 0.2);
      background: rgba(255, 255, 255, 0.85);
      color: var(--text-primary);
      appearance: none;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus {
      border-color: rgba(61, 139, 255, 0.6);
      box-shadow: 0 0 0 4px rgba(61, 139, 255, 0.2);
    }

    #display {
      min-height: 3.2rem;
      display: grid;
      place-items: center;
      padding: 1.2rem;
      font-size: clamp(1.6rem, 4.5vw, 2.4rem);
      font-weight: 600;
      border-radius: 20px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-primary);
      line-height: 1.3;
    }

    .actions {
      display: grid;
      gap: 0.75rem;
    }

    @media (min-width: 480px) {
      .actions {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    #statusMessage {
      min-height: 0;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      font-size: 0.9rem;
      line-height: 1.4;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-secondary);
      box-shadow: inset 0 0 0 1px rgba(61, 139, 255, 0.15);
    }

    #statusMessage[data-type="warn"] {
      background: rgba(243, 156, 18, 0.15);
      color: #8c5a05;
      box-shadow: inset 0 0 0 1px rgba(243, 156, 18, 0.3);
    }

    #statusMessage[data-type="error"] {
      background: rgba(231, 76, 60, 0.18);
      color: #a12315;
      box-shadow: inset 0 0 0 1px rgba(231, 76, 60, 0.35);
    }

    .segmented-control {
      position: relative;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.4rem;
      padding: 0.35rem;
      border-radius: 999px;
      background: rgba(61, 139, 255, 0.08);
      border: 1px solid rgba(61, 139, 255, 0.15);
    }

    .segmented-control input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .segmented-control label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      padding: 0.55rem 0.75rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      background: transparent;
    }

    .segmented-control label::before {
      content: attr(data-icon);
      font-size: 1rem;
    }

    .segmented-control label:hover {
      color: var(--accent-strong);
    }

    .segmented-control input:checked + label {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #fff;
      box-shadow: 0 10px 20px rgba(61, 139, 255, 0.25);
    }

    .advanced-card {
      display: grid;
      gap: 0.9rem;
      padding: 1rem 1.2rem;
      border-radius: 20px;
      background: rgba(26, 42, 58, 0.06);
      border: 1px solid rgba(61, 139, 255, 0.12);
    }

    .advanced-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .advanced-title {
      margin: 0;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .advanced-subtitle {
      margin: 0.2rem 0 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .switch {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 52px;
      height: 30px;
      border-radius: 999px;
    }

    .switch input {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      margin: 0;
      opacity: 0;
      cursor: pointer;
    }

    .switch-track {
      position: relative;
      width: 100%;
      height: 100%;
      background: rgba(61, 139, 255, 0.25);
      border-radius: inherit;
      transition: background 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 1px 2px rgba(26, 42, 58, 0.12);
      pointer-events: none;
    }

    .switch-thumb {
      position: absolute;
      top: 50%;
      left: 6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 4px 10px rgba(26, 42, 58, 0.25);
      transform: translate3d(0, -50%, 0);
      transition: transform 0.2s ease;
    }

    .switch input:checked + .switch-track {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 12px 20px rgba(61, 139, 255, 0.35);
    }

    .switch input:checked + .switch-track .switch-thumb {
      transform: translate3d(22px, -50%, 0);
    }

    button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.85rem 1rem;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      color: #fff;
      background: var(--accent);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      box-shadow: 0 10px 20px rgba(61, 139, 255, 0.25);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.03);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.98);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .progress-container {
      width: 100%;
      height: 10px;
      background: rgba(61, 139, 255, 0.12);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      transition: width 0.25s ease;
    }

    footer {
      text-align: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: grid;
      gap: 0.75rem;
    }

    footer span {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      justify-content: center;
    }

    .stats-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 12px 22px rgba(61, 139, 255, 0.28);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    .stats-button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .stats-button:active {
      transform: translateY(0);
      filter: brightness(0.95);
    }

    .main-actions {
      display: grid;
      gap: 0.75rem;
    }

    .primary-button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.95rem 1.2rem;
      border-radius: 16px;
      border: none;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 12px 24px rgba(61, 139, 255, 0.28);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    .primary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .primary-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .secondary-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.8rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      background: rgba(61, 139, 255, 0.12);
      color: var(--accent-strong);
      transition: transform 0.15s ease, filter 0.2s ease;
    }

    .secondary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .secondary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .danger-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.8rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      background: var(--accent-stop);
      color: #fff;
      box-shadow: 0 10px 20px rgba(231, 76, 60, 0.28);
      transition: transform 0.15s ease, filter 0.2s ease;
    }

    .danger-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .danger-button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      box-shadow: none;
    }

    .ghost-button {
      font-size: 0.9rem;
      font-weight: 600;
      padding: 0.7rem 1rem;
      border-radius: 14px;
      border: 1px solid rgba(61, 139, 255, 0.35);
      background: transparent;
      color: var(--accent-strong);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.15s ease;
    }

    .ghost-button:hover:not(:disabled) {
      transform: translateY(-1px);
      background: rgba(61, 139, 255, 0.12);
    }

    .ghost-button--small {
      padding: 0.45rem 0.8rem;
      font-size: 0.85rem;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: clamp(1.2rem, 4vw, 2rem);
      background: rgba(17, 33, 52, 0.55);
      backdrop-filter: blur(6px);
      z-index: 20;
    }

    .modal-card {
      width: min(540px, 100%);
      background: var(--surface);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow);
      display: grid;
      gap: 1.5rem;
      padding: clamp(1.6rem, 4vw, 2.2rem);
      max-height: min(90vh, 720px);
      overflow-y: auto;
      font-size: 0.95rem;
    }

    .modal-card--narrow {
      width: min(480px, 100%);
    }

    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.4rem;
    }

    .modal-header p {
      margin: 0.35rem 0 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .modal-content {
      display: grid;
      gap: 1.25rem;
    }

    .exercise-overview {
      display: grid;
      gap: 0.65rem;
    }

    .exercise-facts {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 0.5rem;
    }

    .exercise-facts li {
      font-size: 0.85rem;
      padding: 0.65rem 0.8rem;
      border-radius: 12px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-secondary);
    }

    .session-stage {
      display: grid;
      gap: 0.75rem;
    }

    .session-display {
      min-height: 3.2rem;
      display: grid;
      place-items: center;
      padding: 1.3rem;
      font-size: clamp(1.6rem, 4.5vw, 2.4rem);
      font-weight: 600;
      border-radius: 20px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-primary);
      line-height: 1.3;
      text-align: center;
    }

    .session-summary {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    .modal-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
      align-items: center;
    }

    .modal-actions > *:first-child {
      margin-right: auto;
    }

    .session-controls {
      display: flex;
      gap: 0.65rem;
      flex-wrap: wrap;
    }

    .debug-panel {
      max-height: min(60vh, 520px);
      overflow: auto;
      border-radius: 18px;
      background: rgba(26, 42, 58, 0.06);
      border: 1px solid rgba(61, 139, 255, 0.18);
      padding: 1rem;
    }

    .debug-log {
      margin: 0;
      white-space: pre-wrap;
      font-family: "IBM Plex Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    @media (max-width: 520px) {
      .modal-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .modal-actions > *:first-child {
        margin-right: 0;
      }

      .session-controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="app-card">
    <header>
      <h1>üßò Stretch Buddy</h1>
      <p>Weniger Knacken, mehr Flex ‚Äì mit deinem Stretch Buddy.</p>
    </header>

    <div class="input-group">
      <label for="exerciseSelect">√úbung w√§hlen</label>
      <select id="exerciseSelect"><option>Lade √úbungen...</option></select>
    </div>

    <div class="input-group">
      <label for="countdownStepSelect">Countdown-Takt</label>
      <select id="countdownStepSelect"></select>
    </div>

    <div class="input-group">
      <span class="group-label">Sprachausgabe</span>
      <div class="segmented-control" role="radiogroup" aria-label="Sprachausgabe w√§hlen">
        <input type="radio" id="voiceModeAuto" name="voiceMode" value="auto" checked />
        <label for="voiceModeAuto" data-icon="‚òÅÔ∏è">Online &amp; Fallback</label>
        <input type="radio" id="voiceModeLocal" name="voiceMode" value="local" />
        <label for="voiceModeLocal" data-icon="üó£Ô∏è">Nur lokal</label>
      </div>
      <p class="group-hint" id="voiceModeHint"></p>
    </div>

    <div class="main-actions">
      <button id="openSessionBtn" class="primary-button" type="button" disabled>Start</button>
      <button id="viewStatsBtn" type="button" class="stats-button">Statistiken ansehen</button>
    </div>

    <div id="statusMessage" role="status" aria-live="polite" hidden></div>

    <button id="debugLogBtn" type="button" class="ghost-button">Debug Log ansehen</button>
  </div>

  <div class="modal-backdrop" id="exerciseModal" hidden>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="exerciseModalTitle" id="exerciseModalCard">
      <header class="modal-header">
        <div>
          <h2 id="exerciseModalTitle">√úbung</h2>
          <p id="exerciseModalSubtitle">Dein pers√∂nlicher Stretch Buddy begleitet dich.</p>
        </div>
        <button id="sessionCloseBtn" type="button" class="ghost-button ghost-button--small">Schlie√üen</button>
      </header>
      <div class="modal-content">
        <section class="exercise-overview">
          <ul id="exerciseFacts" class="exercise-facts"></ul>
        </section>
        <section class="session-stage">
          <div id="display" class="session-display">Bereit?</div>
          <div class="progress-container" id="repProgressContainer" hidden>
            <div class="progress-bar" id="repProgressBar" aria-hidden="true"></div>
          </div>
        </section>
        <p id="sessionSummary" class="session-summary" hidden></p>
      </div>
      <div class="modal-actions">
        <button id="sessionStartBtn" class="primary-button" type="button">Start</button>
        <div id="sessionControls" class="session-controls" hidden>
          <button id="continueBtn" type="button" class="secondary-button" disabled>Weiter</button>
          <button id="pauseBtn" type="button" class="secondary-button" disabled>Pause</button>
          <button id="stopBtn" type="button" class="danger-button">Abbrechen</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="debugModal" hidden>
    <div class="modal-card modal-card--narrow" role="dialog" aria-modal="true" aria-labelledby="debugModalTitle">
      <header class="modal-header">
        <h2 id="debugModalTitle">Debug Log</h2>
        <button id="closeDebugModal" type="button" class="ghost-button ghost-button--small">Schlie√üen</button>
      </header>
      <div id="debugPanel" class="debug-panel">
        <pre id="debugLog" class="debug-log">Noch keine Eintr√§ge.</pre>
      </div>
    </div>
  </div>

  <script src="./config.production.js"></script>
  <script>
    const countdownStepSelect = document.getElementById("countdownStepSelect");
    const viewStatsBtn = document.getElementById("viewStatsBtn");
    const openSessionBtn = document.getElementById("openSessionBtn");
    const debugLogBtn = document.getElementById("debugLogBtn");
    const exerciseModal = document.getElementById("exerciseModal");
    const sessionCloseBtn = document.getElementById("sessionCloseBtn");
    const exerciseModalTitle = document.getElementById("exerciseModalTitle");
    const exerciseModalSubtitle = document.getElementById("exerciseModalSubtitle");
    const exerciseFacts = document.getElementById("exerciseFacts");
    const sessionSummary = document.getElementById("sessionSummary");
    const sessionControls = document.getElementById("sessionControls");
    const exerciseOverviewSection = document.querySelector(".exercise-overview");

    const COUNTDOWN_MIN_MS = 100;
    const COUNTDOWN_MAX_MS = 1000;
    const COUNTDOWN_STEP_INCREMENT_MS = 100;
    let countdownStepMs = 200;
    let voiceMode = "auto";
    let exercises = [];
    let exercise = null;
    let skipRequested = false;
    let aborted = false;
    let sessionRunning = false;
    let pauseRequested = false;
    let pauseAwaitingResume = false;
    let pauseResumeResolver = null;
    let pauseContext = null;
    const hasBrowserSpeech = "speechSynthesis" in window;
    let currentAudio = null;
    let currentAudioUrl = null;
    let currentFetchController = null;
    let remoteFailureNotified = false;
    let remoteBackoffActive = false;
    let remoteRetryAvailableAt = 0;
    let remoteFailureCount = 0;
    let lastRemoteBackoffLogAt = 0;
    let audioUnlockPromise = null;
    let sharedAudioElement = null;
    let sharedAudioContext = null;
    let audioContextUnlockPromise = null;
    let audioUnlocked = false;
    let lastAudioUnlockError = "";
    let visibleModalCount = 0;

    const display = document.getElementById("display");
    const startBtn = document.getElementById("sessionStartBtn");
    const continueBtn = document.getElementById("continueBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stopBtn = document.getElementById("stopBtn");
    const closeDebugModalBtn = document.getElementById("closeDebugModal");
    const debugModal = document.getElementById("debugModal");
    const select = document.getElementById("exerciseSelect");
    const statusMessage = document.getElementById("statusMessage");
    const voiceModeRadios = Array.from(document.querySelectorAll('input[name="voiceMode"]'));
    const voiceModeHint = document.getElementById("voiceModeHint");
    const debugPanel = document.getElementById("debugPanel");
    const debugLog = document.getElementById("debugLog");
    const debugEntries = [];
    const repProgressContainer = document.getElementById("repProgressContainer");
    const repProgressBar = document.getElementById("repProgressBar");
    const DEBUG_MAX_ENTRIES = 12;
    const REMOTE_SPEECH_SLOW_THRESHOLD_MS = 1500;
    const REMOTE_RETRY_BASE_DELAY_MS = 4000;
    const REMOTE_RETRY_MAX_DELAY_MS = 60000;
    const REMOTE_BACKOFF_LOG_THROTTLE_MS = 3000;
    const SILENT_AUDIO_SRC =
      "data:audio/wav;base64,UklGRrQBAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YZABAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA";
    const now = () => (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now());

    const speechConfig = window.STRETCH_COACH_CONFIG || {};
    const preferredVoice = speechConfig.voiceId ? String(speechConfig.voiceId) : null;
    const SPEECH_API_ENDPOINT = determineSpeechEndpoint(speechConfig);
    const PROGRESS_API_ENDPOINT = determineProgressEndpoint(speechConfig);
    const CLIENT_ID_STORAGE_KEY = "stretchCoachClientId";
    const COMPLETION_REQUEST_TIMEOUT_MS = 8000;
    let cachedClientId = null;

    function stripTrailingSlash(value) {
      return value.replace(/\/+$/, "");
    }

    function determineSpeechEndpoint(config) {
      if (config && config.speechApiUrl) {
        const normalized = stripTrailingSlash(String(config.speechApiUrl));
        return normalized || "/api/speak";
      }
      if (config && config.speechApiBaseUrl) {
        const normalizedBase = stripTrailingSlash(String(config.speechApiBaseUrl));
        return normalizedBase ? `${normalizedBase}/api/speak` : "/api/speak";
      }
      return "/api/speak";
    }

    function determineProgressEndpoint(config) {
      if (config && typeof config.progressApiUrl === "string") {
        const trimmed = config.progressApiUrl.trim();
        if (!trimmed) {
          return "/api/exercise-completions";
        }
        const normalized = stripTrailingSlash(trimmed);
        return normalized || "/api/exercise-completions";
      }
      if (config && config.progressApiUrl === null) {
        return null;
      }
      if (config && typeof config.progressApiBaseUrl === "string") {
        const trimmedBase = config.progressApiBaseUrl.trim();
        if (!trimmedBase) {
          return "/api/exercise-completions";
        }
        const normalizedBase = stripTrailingSlash(trimmedBase);
        return normalizedBase
          ? `${normalizedBase}/api/exercise-completions`
          : "/api/exercise-completions";
      }
      return "/api/exercise-completions";
    }

    function setStatus(message = "", type = "info") {
      if (!statusMessage) return;
      if (!message) {
        statusMessage.textContent = "";
        statusMessage.hidden = true;
        statusMessage.removeAttribute("data-type");
        return;
      }
      statusMessage.hidden = false;
      statusMessage.textContent = message;
      statusMessage.setAttribute("data-type", type);
    }

    function appendDebug(message, details = "") {
      const timestamp = new Date().toLocaleTimeString();
      let entry = `[${timestamp}] ${message}`;
      if (details) {
        entry += `\n${details}`;
      }
      debugEntries.push(entry);
      while (debugEntries.length > DEBUG_MAX_ENTRIES) {
        debugEntries.shift();
      }
      refreshDebugLog();
    }

    function refreshDebugLog() {
      if (!debugLog) return;
      if (!debugEntries.length) {
        debugLog.textContent = "Noch keine Eintr√§ge.";
        return;
      }
      debugLog.textContent = debugEntries.join("\n\n");
    }

    function setModalVisibility(modal, visible) {
      if (!modal) return;
      const currentlyVisible = !modal.hidden;
      if (visible === currentlyVisible) {
        return;
      }
      modal.hidden = !visible;
      modal.setAttribute("aria-hidden", visible ? "false" : "true");
      visibleModalCount += visible ? 1 : -1;
      if (visibleModalCount < 0) {
        visibleModalCount = 0;
      }
      if (typeof document !== "undefined" && document.body) {
        if (visibleModalCount > 0) {
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = "";
        }
      }
    }

    function openModal(modal) {
      setModalVisibility(modal, true);
    }

    function closeModal(modal) {
      setModalVisibility(modal, false);
    }

    function formatFact(label, value, suffix = "") {
      return `${label}: ${value}${suffix}`;
    }

    function updateExerciseOverview(ex) {
      if (exerciseModalTitle) {
        exerciseModalTitle.textContent = ex && ex.name ? ex.name : "√úbung";
      }
      if (exerciseModalSubtitle) {
        if (ex && Number.isInteger(ex.sets) && Number.isInteger(ex.duration)) {
          exerciseModalSubtitle.textContent = `${ex.sets} S√§tze ¬∑ ${ex.duration} Wiederholungen pro Satz`;
        } else if (ex && Number.isInteger(ex.sets)) {
          exerciseModalSubtitle.textContent = `${ex.sets} S√§tze`;
        } else {
          exerciseModalSubtitle.textContent = "Dein pers√∂nlicher Stretch Buddy begleitet dich.";
        }
      }
      if (exerciseFacts) {
        if (!ex) {
          exerciseFacts.innerHTML = "";
        } else {
          const factItems = [];
          const hasSets = Number.isInteger(ex.sets);
          const hasDuration = Number.isInteger(ex.duration);
          if (!(hasSets && hasDuration)) {
            if (hasSets) {
              factItems.push(formatFact("S√§tze", ex.sets));
            }
            if (hasDuration) {
              factItems.push(formatFact("Wiederholungen pro Satz", ex.duration));
            }
          }
          if (Number.isFinite(ex.rep_time)) {
            factItems.push(formatFact("Dauer je Wiederholung", ex.rep_time, " Sekunden"));
          }
          if (Number.isFinite(ex.prep_time)) {
            factItems.push(formatFact("Vorbereitungszeit", ex.prep_time, " Sekunden"));
          }
          if (Number.isFinite(ex.rest_time)) {
            factItems.push(formatFact("Pause zwischen den S√§tzen", ex.rest_time, " Sekunden"));
          }
          exerciseFacts.innerHTML = factItems.map(item => `<li>${item}</li>`).join("");
        }
      }
    }

    function resetProgress() {
      if (!repProgressContainer || !repProgressBar) return;
      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      repProgressContainer.hidden = true;
    }

    function resetSessionUI() {
      sessionRunning = false;
      skipRequested = false;
      aborted = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      if (startBtn) {
        startBtn.hidden = false;
        startBtn.disabled = false;
        startBtn.textContent = "Start";
      }
      if (sessionControls) {
        sessionControls.hidden = true;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = false;
      }
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (stopBtn) {
        stopBtn.disabled = true;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = false;
        sessionCloseBtn.disabled = false;
      }
      if (sessionSummary) {
        sessionSummary.hidden = true;
        sessionSummary.textContent = "";
      }
      resetProgress();
      if (display) {
        const preview = buildInstructionSpeech(exercise);
        display.textContent = preview || (exercise && exercise.name ? exercise.name : "Bereit?");
      }
    }

    function startSessionUI() {
      sessionRunning = true;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      resetProgress();
      if (startBtn) {
        startBtn.disabled = true;
        startBtn.hidden = true;
      }
      if (sessionControls) {
        sessionControls.hidden = false;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = true;
      }
      if (pauseBtn) {
        pauseBtn.disabled = false;
      }
      if (stopBtn) {
        stopBtn.disabled = false;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = true;
      }
      if (sessionSummary) {
        sessionSummary.hidden = true;
        sessionSummary.textContent = "";
      }
    }

    function finishSessionUI({ completed }) {
      sessionRunning = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      if (sessionControls) {
        sessionControls.hidden = true;
      }
      resetProgress();
      if (startBtn) {
        startBtn.hidden = false;
        startBtn.disabled = false;
        startBtn.textContent = completed ? "Nochmals starten" : "Erneut starten";
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = false;
      }
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (stopBtn) {
        stopBtn.disabled = true;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = false;
        sessionCloseBtn.disabled = false;
      }
      if (sessionSummary) {
        sessionSummary.textContent = completed
          ? "Geschafft! Du hast die √úbung abgeschlossen."
          : "√úbung abgebrochen.";
        sessionSummary.hidden = false;
      }
    }

    function resolvePauseAwaiting() {
      pauseRequested = false;
      if (pauseResumeResolver) {
        const resolver = pauseResumeResolver;
        pauseResumeResolver = null;
        pauseAwaitingResume = false;
        pauseContext = null;
        try {
          resolver();
        } catch (_err) {
          // ignore resolve errors
        }
      } else {
        pauseAwaitingResume = false;
        pauseContext = null;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
    }

    async function handlePauseIfNeeded() {
      if (!pauseRequested || aborted) {
        pauseRequested = false;
        return;
      }
      pauseRequested = false;
      pauseAwaitingResume = true;
      pauseContext = "default";
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      appendDebug("Pause aktiviert.");
      if (display) {
        display.textContent = "Pause aktiv!";
      }
      await speak("Pause aktiv!");
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      await new Promise(resolve => {
        pauseResumeResolver = resolve;
      });
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
    }

    async function handleCountdownPause() {
      if (!pauseRequested || aborted) {
        pauseRequested = false;
        return;
      }
      pauseRequested = false;
      pauseAwaitingResume = true;
      pauseContext = "countdown";
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      appendDebug("Countdown wird angehalten.");
      if (display) {
        display.textContent = "Countdown angehalten";
      }
      await speak("Countdown angehalten");
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      await new Promise(resolve => {
        pauseResumeResolver = resolve;
      });
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
    }

    async function resumeFromPause() {
      if (!pauseAwaitingResume) return;
      pauseAwaitingResume = false;
      const resolver = pauseResumeResolver;
      pauseResumeResolver = null;
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      appendDebug("Pause wird beendet.");
      if (pauseContext === "countdown") {
        pauseContext = null;
        if (display) {
          display.textContent = "Countdown wird fortgesetzt";
        }
        await speak("Countdown wird fortgesetzt");
      } else {
        if (display) {
          display.textContent = "Pause endet in 10 Sekunden";
        }
        await speak("Pause Ende in 10 Sekunden");
        await countdown(10, "", "");
        pauseContext = null;
      }
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
      if (typeof resolver === "function") {
        resolver();
      }
    }

    function describeError(error) {
      if (!error) return "Unbekannter Fehler";
      if (error instanceof Error) {
        const name = error.name && error.name !== "Error" ? `${error.name}: ` : "";
        return `${name}${error.message || String(error)}`;
      }
      if (typeof error === "object") {
        try {
          return JSON.stringify(error);
        } catch (_err) {
          return String(error);
        }
      }
      return String(error);
    }

    function safeLocalStorageGetItem(key) {
      try {
        return window.localStorage ? window.localStorage.getItem(key) : null;
      } catch (error) {
        appendDebug("Konnte localStorage nicht lesen.", describeError(error));
        return null;
      }
    }

    function safeLocalStorageSetItem(key, value) {
      try {
        if (window.localStorage) {
          window.localStorage.setItem(key, value);
        }
      } catch (error) {
        appendDebug("Konnte localStorage nicht schreiben.", describeError(error));
      }
    }

    function createClientId() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      const randomPart = Math.random().toString(16).slice(2, 10);
      return `client-${Date.now()}-${randomPart}`;
    }

    function getOrCreateClientId() {
      if (cachedClientId) {
        return cachedClientId;
      }
      const existing = safeLocalStorageGetItem(CLIENT_ID_STORAGE_KEY);
      if (existing && typeof existing === "string" && existing.trim()) {
        cachedClientId = existing.trim();
        return cachedClientId;
      }
      const newId = createClientId();
      cachedClientId = newId;
      safeLocalStorageSetItem(CLIENT_ID_STORAGE_KEY, newId);
      return cachedClientId;
    }

    function isoStringFromTimestamp(timestamp) {
      if (typeof timestamp !== "number" || Number.isNaN(timestamp)) {
        return null;
      }
      try {
        return new Date(timestamp).toISOString();
      } catch (_err) {
        return null;
      }
    }

    function truncateTextForDebug(text, maxLength = 90) {
      if (typeof text !== "string") {
        return "";
      }
      return text.length > maxLength ? `${text.slice(0, maxLength - 1)}‚Ä¶` : text;
    }

    function updateVoiceModeHint() {
      if (!voiceModeHint) return;
      voiceModeHint.textContent =
        voiceMode === "auto"
          ? "Nutze bevorzugt die Online-Stimme. Bei Ausf√§llen springt die lokale Stimme ein."
          : "Die Browser-Stimme √ºbernimmt alle Ansagen ‚Äì funktioniert auch offline.";
    }

    function buildInstructionSpeech(ex) {
      if (!ex) return "";
      const name = (ex.name || "").trim();
      const instruction = (ex.instruction || "").trim();
      if (!instruction) return name;
      if (name && instruction.toLowerCase().startsWith(name.toLowerCase())) {
        const trimmedInstruction = instruction.slice(name.length).replace(/^[\s.:,-]+/, "").trim();
        return trimmedInstruction || instruction;
      }
      return name ? `${name}. ${instruction}` : instruction;
    }

    const initialVoiceMode = voiceModeRadios.find(radio => radio.checked)?.value;
    if (initialVoiceMode) {
      voiceMode = initialVoiceMode;
    }

    updateVoiceModeHint();
    voiceModeRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        if (!radio.checked) return;
        voiceMode = radio.value;
        if (voiceMode !== "auto") {
          remoteFailureNotified = false;
          remoteBackoffActive = false;
          remoteFailureCount = 0;
          remoteRetryAvailableAt = 0;
          lastRemoteBackoffLogAt = 0;
          setStatus("");
        }
        appendDebug(
          voiceMode === "auto"
            ? "Sprachausgabe: Online-Modus mit Fallback aktiviert."
            : "Sprachausgabe: Lokaler Modus aktiviert."
        );
        updateVoiceModeHint();
      });
    });

    function base64ToBlob(base64, mimeType = "audio/mpeg") {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType });
    }

    function cancelActiveSpeech() {
      if (currentFetchController) {
        currentFetchController.abort();
        currentFetchController = null;
      }
      if (currentAudio) {
        currentAudio.pause();
      }
      if (hasBrowserSpeech) {
        speechSynthesis.cancel();
      }
      if (continueBtn) {
        continueBtn.disabled = true;
      }
    }

    async function callSpeechApi(text, { signal } = {}) {
      const payload = { text, language: "de-DE" };
      if (preferredVoice) {
        payload.voice = preferredVoice;
      }

      const response = await fetch(SPEECH_API_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal,
      });

      const contentType = response.headers.get("content-type") || "";

      if (!response.ok) {
        let errorMessage = `Speech API Fehler (${response.status})`;
        if (contentType.includes("application/json")) {
          try {
            const data = await response.json();
            if (data && data.error) {
              errorMessage = data.error;
            }
          } catch (_err) {
            // ignore JSON parsing error
          }
        } else {
          const textMessage = await response.text();
          if (textMessage) {
            errorMessage = textMessage;
          }
        }
        throw new Error(errorMessage);
      }

      if (contentType.includes("application/json")) {
        const data = await response.json();
        if (data && data.audioUrl) {
          const audioResponse = await fetch(data.audioUrl, { signal });
          if (!audioResponse.ok) {
            throw new Error(`Konnte Audio-URL nicht laden (${audioResponse.status}).`);
          }
          return await audioResponse.blob();
        }
        if (data && data.audioBase64) {
          return base64ToBlob(data.audioBase64, data.mimeType || "audio/mpeg");
        }
        if (data && data.error) {
          throw new Error(data.error);
        }
        throw new Error("Unerwartete Antwort der Speech API.");
      }

      return await response.blob();
    }

    async function playRemoteAudio(text) {
      const controller = new AbortController();
      currentFetchController = controller;

      let blob;
      try {
        blob = await callSpeechApi(text, { signal: controller.signal });
      } catch (error) {
        const abortedFetch =
          controller.signal.aborted ||
          skipRequested ||
          aborted ||
          (error && error.name === "AbortError");
        if (abortedFetch) {
          if (continueBtn) {
            continueBtn.disabled = true;
          }
          return;
        }
        throw error;
      } finally {
        if (currentFetchController === controller) {
          currentFetchController = null;
        }
      }

      if (aborted || skipRequested) {
        if (continueBtn) {
          continueBtn.disabled = true;
        }
        return;
      }

      const objectUrl = URL.createObjectURL(blob);
      currentAudioUrl = objectUrl;
      const audio = sharedAudioElement ?? new Audio();
      if (!sharedAudioElement) {
        audio.playsInline = true;
        audio.preload = "auto";
      } else {
        try {
          sharedAudioElement.pause();
        } catch (_err) {
          // ignore pause errors
        }
      }
      audio.muted = false;
      audio.src = objectUrl;
      try {
        audio.currentTime = 0;
      } catch (_err) {
        // ignore time reset errors
      }
      try {
        audio.load();
      } catch (_err) {
        // ignore load errors
      }
      currentAudio = audio;
      if (continueBtn) {
        continueBtn.disabled = false;
      }

      await new Promise((resolve, reject) => {
        let settled = false;

        function cleanup() {
          audio.removeEventListener("ended", onEnded);
          audio.removeEventListener("pause", onPause);
          audio.removeEventListener("error", onError);

          if (currentAudio === audio) {
            currentAudio = null;
          }
          if (currentAudioUrl === objectUrl) {
            URL.revokeObjectURL(objectUrl);
            currentAudioUrl = null;
          }
          if (continueBtn) {
            continueBtn.disabled = true;
          }
          try {
            audio.pause();
          } catch (_err) {
            // ignore pause errors
          }
          if (audio === sharedAudioElement) {
            try {
              audio.removeAttribute("src");
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          } else {
            try {
              audio.src = "";
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          }
        }

        function finish() {
          if (settled) return;
          settled = true;
          cleanup();
          resolve();
        }

        function fail(err) {
          if (settled) return;
          settled = true;
          cleanup();
          reject(err);
        }

        const onEnded = () => finish();
        const onPause = () => {
          if (!audio.ended) {
            finish();
          }
        };
        const onError = event => {
          const error = event instanceof Event && audio.error ? audio.error : null;
          fail(error || new Error("Audio playback failed"));
        };

        audio.addEventListener("ended", onEnded);
        audio.addEventListener("pause", onPause);
        audio.addEventListener("error", onError);

        audio.play().catch(err => {
          if (err && err.name === "NotAllowedError") {
            audioUnlocked = false;
            audioUnlockPromise = null;
            setStatus(
              "Browser blockiert die Audiowiedergabe. Tippe erneut, um sie zu aktivieren.",
              "warn"
            );
            appendDebug(
              "Audiowiedergabe durch den Browser blockiert.",
              describeError(err)
            );
          }
          fail(err);
        });
      });
    }

    function speakWithLocalSynthesis(text) {
      return new Promise(resolve => {
        if (!hasBrowserSpeech) {
          setStatus("Sprachsynthese im Browser nicht verf√ºgbar.", "error");
          appendDebug("Lokale Sprachsynthese des Browsers nicht verf√ºgbar.");
          resolve();
          return;
        }

        continueBtn.disabled = false;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "de-DE";
        utterance.rate = 1;

        let finished = false;
        const cancelWatcher = setInterval(() => {
          if (skipRequested || aborted) {
            speechSynthesis.cancel();
          }
        }, 100);

        let guardTimer = null;

        const cleanup = () => {
          clearInterval(cancelWatcher);
          if (guardTimer) {
            clearTimeout(guardTimer);
            guardTimer = null;
          }
          continueBtn.disabled = true;
        };

        const finish = () => {
          if (finished) return;
          finished = true;
          cleanup();
          resolve();
        };

        const scheduleGuard = () => {
          guardTimer = setTimeout(() => {
            if (speechSynthesis.speaking || speechSynthesis.pending) {
              scheduleGuard();
              return;
            }
            console.warn("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            appendDebug("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            finish();
          }, 4000);
        };

        utterance.onend = () => finish();

        utterance.onerror = () => finish();

        speechSynthesis.cancel();
        scheduleGuard();
        speechSynthesis.speak(utterance);
      });
    }

    function getAudioContextConstructor() {
      return typeof window !== "undefined"
        ? window.AudioContext || window.webkitAudioContext || null
        : null;
    }

    async function unlockAudioContext() {
      const AudioContextCtor = getAudioContextConstructor();
      if (!AudioContextCtor) {
        lastAudioUnlockError = "Keine Web-Audio-Unterst√ºtzung zur Tonfreigabe vorhanden.";
        return false;
      }

      if (audioContextUnlockPromise) {
        return audioContextUnlockPromise;
      }

      const attempt = (async () => {
        try {
          if (!sharedAudioContext) {
            sharedAudioContext = new AudioContextCtor();
          }
          const context = sharedAudioContext;
          if (!context) {
            return false;
          }
          if (context.state === "suspended") {
            await context.resume();
          }

          const frameCount = Math.max(Math.floor(context.sampleRate / 60), 1);
          const buffer = context.createBuffer(1, frameCount, context.sampleRate);
          const source = context.createBufferSource();
          source.buffer = buffer;
          source.connect(context.destination);
          try {
            source.start(0);
          } catch (_err) {
            // ignore start errors if source already stopped
          }
          return true;
        } catch (error) {
          appendDebug("Freischaltung via Web Audio fehlgeschlagen.", describeError(error));
          lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden (Web Audio).";
          return false;
        }
      })();

      audioContextUnlockPromise = attempt
        .then(success => {
          if (!success) {
            audioContextUnlockPromise = null;
          }
          return success;
        })
        .catch(error => {
          audioContextUnlockPromise = null;
          throw error;
        });

      return audioContextUnlockPromise;
    }

    function ensureAudioUnlocked() {
      if (audioUnlockPromise) return audioUnlockPromise;

      if (typeof Audio === "undefined") {
        audioUnlocked = true;
        lastAudioUnlockError = "";
        audioUnlockPromise = Promise.resolve(true);
        return audioUnlockPromise;
      }

      if (!sharedAudioElement) {
        sharedAudioElement = new Audio();
        sharedAudioElement.preload = "auto";
        sharedAudioElement.playsInline = true;
      }

      sharedAudioElement.muted = true;
      sharedAudioElement.src = SILENT_AUDIO_SRC;

      const unlockAttempt = sharedAudioElement
        .play()
        .then(() => true)
        .catch(async err => {
          console.warn("Konnte Audio nicht initialisieren.", err);
          const errorDescription = describeError(err);
          const isNotSupported = err && err.name === "NotSupportedError";
          const isNotAllowed = err && err.name === "NotAllowedError";

          if (isNotSupported) {
            appendDebug(
              "Stille Audiodatei zum Entsperren wird nicht unterst√ºtzt.",
              errorDescription
            );
            lastAudioUnlockError =
              "Browser unterst√ºtzt das Audioformat zur Freischaltung nicht.";
            const contextUnlocked = await unlockAudioContext();
            if (contextUnlocked) {
              lastAudioUnlockError = "";
              return true;
            }
          } else if (isNotAllowed) {
            appendDebug("Browser blockiert die Audiowiedergabe.", errorDescription);
            lastAudioUnlockError =
              "Browser blockiert die Audiowiedergabe. Bitte tippe erneut, um Ton zu aktivieren.";
          } else {
            appendDebug("Audio konnte nicht freigeschaltet werden.", errorDescription);
            lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden.";
          }
          return false;
        })
        .finally(() => {
          try {
            sharedAudioElement.pause();
            sharedAudioElement.currentTime = 0;
            sharedAudioElement.removeAttribute("src");
            sharedAudioElement.load();
          } catch (_err) {
            // ignore cleanup errors
          }
          sharedAudioElement.muted = false;
        });

      audioUnlockPromise = unlockAttempt.then(success => {
        audioUnlocked = success;
        if (!success) {
          audioUnlockPromise = null;
        }
        return success;
      });

      return audioUnlockPromise;
    }

    const userActivationEvents = ["pointerdown", "touchstart", "keydown"];
    userActivationEvents.forEach(eventName => {
      window.addEventListener(
        eventName,
        () => {
          if (!audioUnlocked) {
            ensureAudioUnlocked();
          }
        },
        { once: true, capture: true }
      );
    });

    async function speak(text) {
      if (aborted) return;

      skipRequested = false;

      const attemptStart = now();
      const truncatedText = truncateTextForDebug(text);
      const preferRemote = voiceMode === "auto";
      const canUseRemote = preferRemote && (!remoteBackoffActive || now() >= remoteRetryAvailableAt);

      if (preferRemote && canUseRemote) {
        try {
          await playRemoteAudio(text);
          const duration = Math.round(now() - attemptStart);
          if (duration > REMOTE_SPEECH_SLOW_THRESHOLD_MS && truncatedText) {
            appendDebug(
              `Online-Sprachsynthese ben√∂tigte ${duration} ms f√ºr eine Antwort.`,
              `Text: "${truncatedText}"`
            );
          }
          if (remoteFailureNotified) {
            if (truncatedText) {
              appendDebug(
                "Online-Sprachsynthese wieder verf√ºgbar.",
                `Text: "${truncatedText}"`
              );
            } else {
              appendDebug("Online-Sprachsynthese wieder verf√ºgbar.");
            }
            setStatus("");
            remoteFailureNotified = false;
          }
          remoteFailureCount = 0;
          remoteBackoffActive = false;
          remoteRetryAvailableAt = 0;
          lastRemoteBackoffLogAt = 0;
          return;
        } catch (error) {
          if (aborted || skipRequested || (error && error.name === "AbortError")) {
            return;
          }
          const duration = Math.round(now() - attemptStart);
          console.warn("Speech API nicht erreichbar, nutze Fallback.", error);
          const details = [
            `Grund: ${describeError(error)}`,
            truncatedText ? `Text: "${truncatedText}"` : "",
          ]
            .filter(Boolean)
            .join("\n");
          appendDebug(
            `Online-Sprachsynthese fehlgeschlagen nach ${duration} ms.`,
            details
          );
          if (preferRemote && !remoteFailureNotified) {
            setStatus(
              "Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.",
              "warn"
            );
            remoteFailureNotified = true;
          }
          remoteFailureCount = Math.min(remoteFailureCount + 1, 6);
          const backoffExponent = Math.max(remoteFailureCount - 1, 0);
          const backoffDelay = Math.min(
            REMOTE_RETRY_BASE_DELAY_MS * Math.pow(2, backoffExponent),
            REMOTE_RETRY_MAX_DELAY_MS
          );
          remoteRetryAvailableAt = now() + backoffDelay;
          remoteBackoffActive = true;
          lastRemoteBackoffLogAt = 0;
          const backoffSeconds = Math.max(1, Math.round(backoffDelay / 1000));
          appendDebug(`Online-Sprachsynthese pausiert f√ºr ${backoffSeconds} s.`);
          skipRequested = false;
          if (truncatedText) {
            appendDebug(
              "Wechsle auf lokale Sprachsynthese.",
              `Text: "${truncatedText}"`
            );
          } else {
            appendDebug("Wechsle auf lokale Sprachsynthese.");
          }
          await speakWithLocalSynthesis(text);
          return;
        }
      }

      if (preferRemote) {
        if (!remoteFailureNotified) {
          setStatus(
            "Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.",
            "warn"
          );
          remoteFailureNotified = true;
        }

        if (remoteBackoffActive) {
          const remainingMs = Math.max(remoteRetryAvailableAt - now(), 0);
          if (
            !lastRemoteBackoffLogAt ||
            now() - lastRemoteBackoffLogAt >= REMOTE_BACKOFF_LOG_THROTTLE_MS
          ) {
            const secondsRemaining = Math.max(1, Math.ceil(remainingMs / 1000));
            const logMessage = `√úberspringe Online-Sprachsynthese (noch ${secondsRemaining} s Auszeit).`;
            const details = truncatedText ? `Text: "${truncatedText}"` : "";
            appendDebug(logMessage, details);
            lastRemoteBackoffLogAt = now();
          }
        }
      } else {
        if (remoteFailureNotified) {
          setStatus("");
          remoteFailureNotified = false;
        }
        remoteBackoffActive = false;
        remoteRetryAvailableAt = 0;
        lastRemoteBackoffLogAt = 0;
      }

      skipRequested = false;
      await speakWithLocalSynthesis(text);
      return;
    }

    // --- √úbungen laden ---
    fetch("exercises.json")
      .then(res => res.json())
      .then(data => {
        exercises = data;
        select.innerHTML = data.map(e => `<option value="${e.id}">${e.name}</option>`).join("");
        exercise = exercises[0] ?? null;
        updateExerciseOverview(exercise);
        resetSessionUI();
        if (openSessionBtn) {
          openSessionBtn.disabled = exercises.length === 0;
        }
      })
      .catch(err => {
        console.error("Fehler beim Laden der √úbungen", err);
        select.innerHTML = "<option>Fehler beim Laden</option>";
        setStatus("√úbungen konnten nicht geladen werden.", "error");
      });

    countdownStepSelect.innerHTML = Array.from(
      { length: Math.floor((COUNTDOWN_MAX_MS - COUNTDOWN_MIN_MS) / COUNTDOWN_STEP_INCREMENT_MS) + 1 },
      (_, idx) => {
        const value = COUNTDOWN_MIN_MS + idx * COUNTDOWN_STEP_INCREMENT_MS;
        const selected = value === countdownStepMs ? " selected" : "";
        return `<option value="${value}"${selected}>${value} ms</option>`;
      }
    ).join("");

    // --- Countdown ---
    async function countdown(seconds, label = "", finalCue = "") {
      let remaining = seconds;
      const buildLabel = value => `${label}${label ? " " : ""}${value}`;
      while (remaining > 0) {
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
          continue;
        }
        const text = buildLabel(remaining);
        display.textContent = text;
        await speak(remaining.toString());
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
          continue;
        }
        await new Promise(r => setTimeout(r, countdownStepMs));
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
        }
        remaining -= 1;
      }
      if (finalCue && !aborted) {
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
        }
        display.textContent = finalCue;
        await speak(finalCue);
      }
    }

    async function runRepTimer(seconds) {
      const totalDurationMs = Math.max(0, seconds * 1000);
      if (totalDurationMs <= 0) {
        return;
      }
      if (!repProgressContainer || !repProgressBar) {
        await new Promise(r => setTimeout(r, totalDurationMs));
        return;
      }

      repProgressContainer.hidden = false;
      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      void repProgressBar.offsetWidth; // Force reflow to restart transition
      repProgressBar.style.transition = "width 0.25s ease";

      const steps = Math.max(1, Math.round(seconds));
      const finalStepDuration = Math.max(totalDurationMs - (steps - 1) * 1000, 0);

      for (let step = 1; step <= steps; step++) {
        if (aborted) break;
        const waitMs = step === steps ? finalStepDuration || 1000 : 1000;
        if (waitMs > 0) {
          await new Promise(r => setTimeout(r, waitMs));
        }
        if (aborted) break;
        const progress = Math.min((step / steps) * 100, 100);
        repProgressBar.style.width = `${progress}%`;
      }

      if (!aborted) {
        await new Promise(r => setTimeout(r, 150));
      }

      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      repProgressContainer.hidden = true;
    }

    // --- Satz ---
    async function runSet(setNr, withPrep) {
      if (aborted) return;
      if (withPrep) {
        display.textContent = `Vorbereitung (Satz ${setNr})...`;
        await speak(`${exercise.prep_time} Sekunden Countdown`);
        await countdown(exercise.prep_time, "", "Los!");
      } else {
        await speak("Weiter mit dem n√§chsten Satz. Los!");
      }

      for (let i = 1; i <= exercise.duration && !aborted; i++) {
        display.textContent = `Wiederholung ${i}`;
        await runRepTimer(exercise.rep_time);
        if (aborted) break;
        await speak(i.toString());
        if (aborted) break;
        await handlePauseIfNeeded();
      }

      if (!aborted) {
        display.textContent = `Satz ${setNr} beendet!`;
        await speak(`Satz ${setNr} beendet.`);
      }
    }

    async function recordExerciseCompletion({
      exercise: exerciseToStore,
      totalSets,
      completedSets,
      startedAt,
      finishedAt,
      durationMs,
    }) {
      if (!exerciseToStore || !exerciseToStore.id) {
        return;
      }
      if (!PROGRESS_API_ENDPOINT) {
        appendDebug("Fortschritts-API ist nicht konfiguriert.");
        return;
      }

      const clientId = getOrCreateClientId();
      if (!clientId) {
        appendDebug("Kein Client-Identifier verf√ºgbar ‚Äì Fortschritt wird nicht gespeichert.");
        return;
      }

      const resolvedTotalSets = Number.isInteger(totalSets)
        ? totalSets
        : Number.isInteger(exerciseToStore.sets)
        ? exerciseToStore.sets
        : 0;
      const resolvedCompletedSets = Number.isInteger(completedSets)
        ? completedSets
        : resolvedTotalSets;

      if (resolvedTotalSets <= 0 || resolvedCompletedSets < resolvedTotalSets) {
        appendDebug("√úbung nicht vollst√§ndig abgeschlossen ‚Äì kein Speichern.");
        return;
      }

      const payload = {
        clientId,
        exerciseId: String(exerciseToStore.id),
        totalSets: resolvedTotalSets,
        setsCompleted: resolvedCompletedSets,
      };

      if (exerciseToStore.name) {
        payload.exerciseName = String(exerciseToStore.name);
      }
      if (Number.isInteger(exerciseToStore.rep_time) && exerciseToStore.rep_time > 0) {
        payload.repTime = Math.trunc(exerciseToStore.rep_time);
      }
      if (Number.isInteger(exerciseToStore.rest_time) && exerciseToStore.rest_time >= 0) {
        payload.restTime = Math.trunc(exerciseToStore.rest_time);
      }
      if (Number.isInteger(exerciseToStore.prep_time) && exerciseToStore.prep_time >= 0) {
        payload.prepTime = Math.trunc(exerciseToStore.prep_time);
      }
      if (Number.isInteger(durationMs) && durationMs >= 0) {
        payload.durationMs = durationMs;
      }

      const startedIso = isoStringFromTimestamp(startedAt);
      if (startedIso) {
        payload.startedAt = startedIso;
      }
      const finishedIso = isoStringFromTimestamp(finishedAt);
      if (finishedIso) {
        payload.finishedAt = finishedIso;
      }

      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), COMPLETION_REQUEST_TIMEOUT_MS);
      appendDebug(
        `Speichere √úbungsabschluss f√ºr '${payload.exerciseName || payload.exerciseId}'.`,
        `S√§tze: ${resolvedCompletedSets}/${resolvedTotalSets}`
      );

      try {
        const response = await fetch(PROGRESS_API_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        if (!response.ok) {
          const contentType = response.headers.get("content-type") || "";
          let errorDetail = `${response.status}`;
          if (contentType.includes("application/json")) {
            try {
              const data = await response.json();
              if (data && data.error) {
                errorDetail = `${response.status} ${data.error}`;
              }
            } catch (_err) {
              // ignore JSON parse error
            }
          } else {
            const text = await response.text();
            if (text) {
              errorDetail = `${response.status} ${text}`;
            }
          }
          appendDebug("Fortschritt konnte nicht gespeichert werden.", errorDetail);
          return;
        }

        appendDebug("Fortschritt erfolgreich gespeichert.");
      } catch (error) {
        if (controller.signal.aborted) {
          appendDebug("Fortschrittsspeicherung abgebrochen (Timeout).");
        } else {
          appendDebug("Fehler beim Speichern des Fortschritts.", describeError(error));
        }
      } finally {
        window.clearTimeout(timeoutId);
      }
    }

    // --- Training ---
    async function doExercise() {
      aborted = false;
      skipRequested = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;

      if (!remoteFailureNotified) {
        setStatus("");
      }

      resetProgress();

      const instructionSpeech = buildInstructionSpeech(exercise);
      if (instructionSpeech) {
        display.textContent = instructionSpeech;
      } else if (exercise && exercise.name) {
        display.textContent = exercise.name;
      }
      await speak(`Pro √úbungsdurchf√ºhrung sind ${exercise.rep_time} Sekunden geplant.`);
      if (instructionSpeech) {
        await speak(instructionSpeech);
      }

      const exerciseStartAt = Date.now();
      let completedSets = 0;

      for (let set = 1; set <= exercise.sets && !aborted; set++) {
        const withPrep = (set === 1);
        await runSet(set, withPrep);
        if (aborted) break;

        completedSets += 1;

        if (set < exercise.sets) {
          await speak(`Pause ${exercise.rest_time} Sekunden.`);
          display.textContent = `Pause: ${exercise.rest_time}s`;
          await new Promise(r => setTimeout(r, (exercise.rest_time - 5) * 1000));
          if (aborted) break;
          await speak("Noch f√ºnf Sekunden");
          await countdown(5, "", ""); // kein Los! hier
        }
      }

      const exerciseFinishedAt = Date.now();

      if (!aborted) {
        display.textContent = "Fertig! Gut gemacht üéâ";
        await speak("Fertig! Gut gemacht.");
        await recordExerciseCompletion({
          exercise,
          totalSets: exercise.sets,
          completedSets,
          startedAt: exerciseStartAt,
          finishedAt: exerciseFinishedAt,
          durationMs: Math.max(0, exerciseFinishedAt - exerciseStartAt),
        });
      } else {
        display.textContent = "Abgebrochen.";
        await speak("Training abgebrochen.");
      }
    }

    // --- Events ---
    select.addEventListener("change", () => {
      const id = select.value;
      exercise = exercises.find(e => e.id === id) ?? null;
      updateExerciseOverview(exercise);
      if (openSessionBtn) {
        openSessionBtn.disabled = !exercise;
      }
      const modalVisible = exerciseModal && !exerciseModal.hidden;
      if (!sessionRunning && modalVisible) {
        resetSessionUI();
      } else if (!sessionRunning && display) {
        const preview = buildInstructionSpeech(exercise);
        display.textContent = preview || (exercise && exercise.name ? exercise.name : "Bereit?");
      }
    });

    if (openSessionBtn) {
      openSessionBtn.addEventListener("click", () => {
        exercise = exercises.find(e => e.id === select.value) ?? null;
        if (!exercise) {
          setStatus("Bitte zuerst eine √úbung ausw√§hlen.", "warn");
          return;
        }
        updateExerciseOverview(exercise);
        resetSessionUI();
        openModal(exerciseModal);
      });
    }

    if (sessionCloseBtn) {
      sessionCloseBtn.addEventListener("click", () => {
        if (sessionRunning) {
          return;
        }
        closeModal(exerciseModal);
      });
    }

    if (startBtn) {
      startBtn.addEventListener("click", async () => {
        if (sessionRunning) return;
        exercise = exercises.find(e => e.id === select.value) ?? null;
        if (!exercise) return;
        const unlocked = await ensureAudioUnlocked();
        if (!unlocked) {
          const warningMessage =
            lastAudioUnlockError ||
            "Audioausgabe wurde vom Browser blockiert. Bitte tippe erneut oder pr√ºfe die Autoplay-Einstellungen.";
          setStatus(warningMessage, "warn");
          appendDebug(
            "Audio konnte nicht freigeschaltet werden.",
            lastAudioUnlockError ? truncateTextForDebug(lastAudioUnlockError, 200) : ""
          );
          return;
        }
        lastAudioUnlockError = "";
        startSessionUI();
        try {
          await doExercise();
          finishSessionUI({ completed: !aborted });
        } catch (error) {
          console.error("Fehler w√§hrend der √úbung", error);
          appendDebug("Fehler w√§hrend der √úbung.", describeError(error));
          finishSessionUI({ completed: false });
        }
      });
    }

    if (continueBtn) {
      continueBtn.addEventListener("click", async () => {
        if (continueBtn.disabled) return;
        if (pauseAwaitingResume) {
          await resumeFromPause();
          return;
        }
        skipRequested = true;
        if (currentFetchController) {
          currentFetchController.abort();
        }
        if (currentAudio) {
          currentAudio.pause();
        } else if (hasBrowserSpeech) {
          speechSynthesis.cancel();
        }
        continueBtn.disabled = true;
      });
    }

    if (pauseBtn) {
      pauseBtn.addEventListener("click", () => {
        if (!sessionRunning || pauseRequested || pauseAwaitingResume) {
          return;
        }
        pauseRequested = true;
        pauseBtn.disabled = true;
        appendDebug("Pause wird nach der aktuellen Wiederholung aktiviert.");
      });
    }
    countdownStepSelect.addEventListener("change", () => {
      countdownStepMs = Number(countdownStepSelect.value);
    });
    if (stopBtn) {
      stopBtn.addEventListener("click", () => {
        if (!sessionRunning) {
          return;
        }
        const shouldAbort = window.confirm("M√∂chtest du die √úbung wirklich abbrechen?");
        if (!shouldAbort) {
          return;
        }
        aborted = true;
        pauseRequested = false;
        skipRequested = false;
        resolvePauseAwaiting();
        cancelActiveSpeech();
        if (display) {
          display.textContent = "Abbruch...";
        }
        if (continueBtn) {
          continueBtn.disabled = true;
        }
        if (pauseBtn) {
          pauseBtn.disabled = true;
        }
        stopBtn.disabled = true;
        remoteFailureNotified = false;
        setStatus("Training gestoppt.", "info");
        appendDebug("Training wurde abgebrochen.");
        resetProgress();
      });
    }

    if (debugLogBtn) {
      debugLogBtn.addEventListener("click", () => {
        refreshDebugLog();
        openModal(debugModal);
      });
    }

    if (closeDebugModalBtn) {
      closeDebugModalBtn.addEventListener("click", () => {
        closeModal(debugModal);
      });
    }

    if (debugModal) {
      closeModal(debugModal);
      debugModal.addEventListener("click", event => {
        if (event.target === debugModal) {
          closeModal(debugModal);
        }
      });
    }

    if (viewStatsBtn) {
      viewStatsBtn.addEventListener("click", () => {
        window.location.href = "./exercise-completions.html";
      });
    }

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./service-worker.js")
          .catch(err => console.error("Service Worker registration failed", err));
      });
    }
  </script>
</body>
</html>
