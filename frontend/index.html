<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#3d8bff" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <title>Stretch Buddy</title>
  <style>
    :root {
      color-scheme: light;
      --bg-gradient: linear-gradient(135deg, #7f7fd5, #86a8e7, #91eae4);
      --surface: rgba(255, 255, 255, 0.9);
      --text-primary: #1a2a3a;
      --text-secondary: #516170;
      --accent: #3d8bff;
      --accent-strong: #2f6ad8;
      --accent-warn: #f39c12;
      --accent-stop: #e74c3c;
      --radius-large: 24px;
      --shadow: 0 20px 40px rgba(26, 42, 58, 0.18);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
        "Helvetica Neue", Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    [hidden] {
      display: none !important;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4vw 5vw;
      background: var(--bg-gradient);
      color: var(--text-primary);
    }

    .app-card {
      width: min(440px, 100%);
      padding: clamp(1.8rem, 4vw, 2.6rem);
      background: var(--surface);
      backdrop-filter: blur(10px);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow);
      display: grid;
      gap: clamp(1rem, 2.5vw, 1.6rem);
    }

    header {
      text-align: center;
      display: grid;
      gap: 0.4rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 4vw, 2.4rem);
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    .streak-indicator {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      margin: 0 auto;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      background: rgba(243, 156, 18, 0.18);
      color: #c26a00;
      font-weight: 600;
      font-size: 0.95rem;
      box-shadow: inset 0 0 0 1px rgba(243, 156, 18, 0.3);
    }

    .streak-indicator[hidden] {
      display: none !important;
    }

    .streak-indicator__icon {
      font-size: 1.15rem;
      line-height: 1;
    }

    .streak-indicator__value {
      font-variant-numeric: tabular-nums;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    .switch-labeled {
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
      margin: 0;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .switch-labeled .switch-label-text {
      font-size: 0.9rem;
    }

    .switch-labeled .switch-state {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-primary);
      min-width: 2.2rem;
      text-align: center;
    }

    .switch-labeled[data-disabled="true"] {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .input-group {
      display: grid;
      gap: 0.6rem;
    }

    .group-label {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    select {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border-radius: 16px;
      border: 1px solid rgba(61, 139, 255, 0.2);
      background: rgba(255, 255, 255, 0.85);
      color: var(--text-primary);
      appearance: none;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus {
      border-color: rgba(61, 139, 255, 0.6);
      box-shadow: 0 0 0 4px rgba(61, 139, 255, 0.2);
    }

    #display {
      min-height: 3.2rem;
      display: grid;
      place-items: center;
      padding: 1.2rem;
      font-size: clamp(1.6rem, 4.5vw, 2.4rem);
      font-weight: 600;
      border-radius: 20px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-primary);
      line-height: 1.3;
    }

    .actions {
      display: grid;
      gap: 0.75rem;
    }

    @media (min-width: 480px) {
      .actions {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    #statusMessage {
      min-height: 0;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      font-size: 0.9rem;
      line-height: 1.4;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-secondary);
      box-shadow: inset 0 0 0 1px rgba(61, 139, 255, 0.15);
    }

    #statusMessage[data-type="warn"] {
      background: rgba(243, 156, 18, 0.15);
      color: #8c5a05;
      box-shadow: inset 0 0 0 1px rgba(243, 156, 18, 0.3);
    }

    #statusMessage[data-type="error"] {
      background: rgba(231, 76, 60, 0.18);
      color: #a12315;
      box-shadow: inset 0 0 0 1px rgba(231, 76, 60, 0.35);
    }

    .segmented-control {
      position: relative;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.4rem;
      padding: 0.35rem;
      border-radius: 999px;
      background: rgba(61, 139, 255, 0.08);
      border: 1px solid rgba(61, 139, 255, 0.15);
    }

    .segmented-control input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .segmented-control label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      padding: 0.55rem 0.75rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      background: transparent;
    }

    .segmented-control label::before {
      content: attr(data-icon);
      font-size: 1rem;
    }

    .segmented-control label:hover {
      color: var(--accent-strong);
    }

    .segmented-control input:checked + label {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #fff;
      box-shadow: 0 10px 20px rgba(61, 139, 255, 0.25);
    }

    .advanced-card {
      display: grid;
      gap: 0.9rem;
      padding: 1rem 1.2rem;
      border-radius: 20px;
      background: rgba(26, 42, 58, 0.06);
      border: 1px solid rgba(61, 139, 255, 0.12);
    }

    .advanced-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .advanced-title {
      margin: 0;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .advanced-subtitle {
      margin: 0.2rem 0 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .switch {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 52px;
      height: 30px;
      border-radius: 999px;
    }

    .switch input {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      margin: 0;
      opacity: 0;
      cursor: pointer;
    }

    .switch-track {
      position: relative;
      width: 100%;
      height: 100%;
      background: rgba(61, 139, 255, 0.25);
      border-radius: inherit;
      transition: background 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 1px 2px rgba(26, 42, 58, 0.12);
      pointer-events: none;
    }

    .switch-thumb {
      position: absolute;
      top: 50%;
      left: 6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 4px 10px rgba(26, 42, 58, 0.25);
      transform: translate3d(0, -50%, 0);
      transition: transform 0.2s ease;
    }

    .switch input:checked + .switch-track {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 12px 20px rgba(61, 139, 255, 0.35);
    }

    .switch input:checked + .switch-track .switch-thumb {
      transform: translate3d(22px, -50%, 0);
    }

    button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.85rem 1rem;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      color: #fff;
      background: var(--accent);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      box-shadow: 0 10px 20px rgba(61, 139, 255, 0.25);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.03);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.98);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .progress-container {
      width: 100%;
      height: 10px;
      background: rgba(61, 139, 255, 0.12);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      transition: width 0.25s ease;
    }

    footer {
      text-align: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: grid;
      gap: 0.75rem;
    }

    footer span {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      justify-content: center;
    }

    .stats-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      border: 2px solid rgba(61, 139, 255, 0.45);
      cursor: pointer;
      background: transparent;
      color: var(--accent-strong);
      box-shadow: none;
      transition: background 0.2s ease, color 0.2s ease, transform 0.15s ease,
        border-color 0.2s ease;
    }

    .stats-button:hover {
      transform: translateY(-1px);
      background: rgba(61, 139, 255, 0.08);
      border-color: rgba(61, 139, 255, 0.65);
    }

    .stats-button:active {
      transform: translateY(0);
      background: rgba(61, 139, 255, 0.12);
    }

    .main-actions {
      display: grid;
      gap: 1.25rem;
    }

    .primary-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
      align-items: stretch;
    }

    @media (max-width: 420px) {
      .primary-actions {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .mindfulness-button {
      background: linear-gradient(135deg, #a855f7, #7c3aed);
      box-shadow: 0 12px 24px rgba(124, 58, 237, 0.32);
      grid-column: 1 / -1;
    }

    .mindfulness-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .mindfulness-button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.97);
    }

    .secondary-actions {
      display: grid;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .secondary-actions .ghost-button {
      justify-content: center;
      text-decoration: none;
      width: 100%;
    }

    .primary-button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.95rem 1.2rem;
      border-radius: 16px;
      border: none;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      box-shadow: 0 12px 24px rgba(61, 139, 255, 0.28);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    .primary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .primary-button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    .beats-radio-button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.95rem 1.2rem;
      border-radius: 16px;
      border: none;
      cursor: pointer;
      color: #4b3a00;
      background: linear-gradient(135deg, #fbe79d, #facc15);
      box-shadow: 0 12px 24px rgba(250, 204, 21, 0.28);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    .beats-radio-button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .beats-radio-button:active {
      transform: translateY(0);
      filter: brightness(0.97);
    }

    .secondary-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.8rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      background: rgba(61, 139, 255, 0.12);
      color: var(--accent-strong);
      transition: transform 0.15s ease, filter 0.2s ease;
    }

    .secondary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .secondary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .danger-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.8rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      background: var(--accent-stop);
      color: #fff;
      box-shadow: 0 10px 20px rgba(231, 76, 60, 0.28);
      transition: transform 0.15s ease, filter 0.2s ease;
    }

    .danger-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .danger-button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      box-shadow: none;
    }

    .ghost-button {
      font-size: 0.9rem;
      font-weight: 600;
      padding: 0.7rem 1rem;
      border-radius: 14px;
      border: 1px solid rgba(61, 139, 255, 0.35);
      background: transparent;
      color: var(--accent-strong);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      transition: background 0.2s ease, color 0.2s ease, transform 0.15s ease;
    }

    .ghost-button:hover:not(:disabled) {
      transform: translateY(-1px);
      background: rgba(61, 139, 255, 0.12);
    }

    .ghost-button--small {
      padding: 0.45rem 0.8rem;
      font-size: 0.85rem;
    }

    #debugLogBtn {
      margin-top: 1.5rem;
      width: 100%;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: clamp(1.2rem, 4vw, 2rem);
      background: rgba(17, 33, 52, 0.55);
      backdrop-filter: blur(6px);
      z-index: 20;
    }

    .modal-card {
      width: min(540px, 100%);
      background: var(--surface);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow);
      display: grid;
      gap: 1.5rem;
      padding: clamp(1.6rem, 4vw, 2.2rem);
      max-height: min(90vh, 720px);
      overflow-y: auto;
      font-size: 0.95rem;
    }

    .modal-card--narrow {
      width: min(480px, 100%);
    }

    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.4rem;
    }

    .modal-header p {
      margin: 0.35rem 0 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .modal-content {
      display: grid;
      gap: 1.25rem;
    }

    .exercise-overview {
      display: flex;
      gap: 0.65rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .details-button {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      background: rgba(61, 139, 255, 0.12);
      color: var(--accent-strong);
      transition: transform 0.15s ease, filter 0.2s ease;
    }

    .details-button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .details-button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.95);
    }

    .details-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      filter: none;
    }

    .exercise-facts {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 0.5rem;
    }

    .exercise-facts li {
      font-size: 0.85rem;
      padding: 0.65rem 0.8rem;
      border-radius: 12px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-secondary);
    }

    .session-stage {
      display: grid;
      gap: 0.75rem;
    }

    .rep-selection-group {
      display: grid;
      gap: 0.75rem;
    }

    @media (min-width: 720px) {
      .rep-selection-group {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
    }

    .rep-selection {
      display: grid;
      gap: 0.45rem;
      padding: 0.85rem 1rem;
      border-radius: 18px;
      background: rgba(61, 139, 255, 0.08);
      border: 1px solid rgba(61, 139, 255, 0.15);
    }

    .rep-selection__label {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      font-weight: 600;
      color: var(--text-secondary);
      font-size: 0.95rem;
      gap: 0.75rem;
    }

    .rep-selection__value {
      font-weight: 700;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
    }

    .rep-selection input[type="range"] {
      width: 100%;
      accent-color: var(--accent-strong);
    }

    .rep-selection input[type="range"]:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .rep-selection[data-disabled="true"] {
      opacity: 0.65;
    }

    .session-display {
      min-height: 3.2rem;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 1.3rem;
      font-size: clamp(1.6rem, 4.5vw, 2.4rem);
      font-weight: 600;
      border-radius: 20px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-primary);
      line-height: 1.3;
      text-align: left;
    }

    .session-summary {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    .modal-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
      align-items: center;
    }

    .modal-actions > *:first-child {
      margin-right: auto;
    }

    .start-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .start-controls .switch-labeled {
      margin-left: auto;
    }

    .exercise-details-content {
      display: grid;
      gap: 1rem;
    }

    .exercise-details-instruction {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
      line-height: 1.45;
    }

    .session-controls {
      display: flex;
      gap: 0.65rem;
      flex-wrap: wrap;
    }

    .debug-panel {
      max-height: min(60vh, 520px);
      overflow: auto;
      border-radius: 18px;
      background: rgba(26, 42, 58, 0.06);
      border: 1px solid rgba(61, 139, 255, 0.18);
      padding: 1rem;
    }

    .debug-log {
      margin: 0;
      white-space: pre-wrap;
      font-family: "IBM Plex Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    @media (max-width: 520px) {
      .modal-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .modal-actions > *:first-child {
        margin-right: 0;
      }

      .session-controls {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="app-card">
    <header>
      <h1>üßò Stretch Buddy</h1>
      <p>Weniger Knacken, mehr Flex!</p>
      <div
        id="streakIndicator"
        class="streak-indicator"
        role="status"
        aria-live="polite"
        hidden
      >
        <span class="streak-indicator__icon" aria-hidden="true">üî•</span>
        <span class="streak-indicator__value" id="streakCount">0</span>
        <span class="streak-indicator__label" id="streakLabel">Tage am St√ºck</span>
      </div>
    </header>

    <div class="input-group">
      <label for="exerciseSelect">√úbung</label>
      <select id="exerciseSelect"><option>Lade √úbungen...</option></select>
    </div>

    <div class="input-group">
      <label for="countdownStepSelect">Countdown-Geschwindigkeit</label>
      <select id="countdownStepSelect"></select>
    </div>

    <div class="input-group">
      <span class="group-label">Sprachausgabe</span>
      <div class="segmented-control" role="radiogroup" aria-label="Sprachausgabe w√§hlen">
        <input type="radio" id="voiceModeAuto" name="voiceMode" value="auto" checked />
        <label for="voiceModeAuto" data-icon="‚òÅÔ∏è">Online &amp; Fallback</label>
        <input type="radio" id="voiceModeLocal" name="voiceMode" value="local" />
        <label for="voiceModeLocal" data-icon="üó£Ô∏è">Nur lokal</label>
      </div>
    </div>

    <div class="main-actions">
      <div class="primary-actions">
        <button id="openSessionBtn" class="primary-button" type="button" disabled>Start</button>
        <button id="beatsRadioBtn" class="beats-radio-button" type="button">Beats Radio</button>
        <button id="mindfulnessPromptBtn" class="mindfulness-button" type="button">Achtsamkeitsspruch</button>
      </div>
      <div class="secondary-actions">
        <button id="viewStatsBtn" type="button" class="stats-button">Statistiken ansehen</button>
        <a class="ghost-button" href="./manage-exercises.html">Trainings bearbeiten</a>
      </div>
    </div>

    <div id="statusMessage" role="status" aria-live="polite" hidden></div>

    <button id="debugLogBtn" type="button" class="ghost-button">Debug Log ansehen</button>
  </div>

  <div class="modal-backdrop" id="exerciseModal" hidden>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="exerciseModalTitle" id="exerciseModalCard">
      <header class="modal-header">
        <div>
          <h2 id="exerciseModalTitle">√úbung</h2>
        </div>
        <button id="sessionCloseBtn" type="button" class="ghost-button ghost-button--small">Schlie√üen</button>
      </header>
      <div class="modal-content">
        <section class="exercise-overview">
          <button id="exerciseDetailsBtn" type="button" class="details-button">Details</button>
        </section>
        <section class="session-stage">
          <div id="display" class="session-display">Bereit?</div>
          <div class="progress-container" id="repProgressContainer" hidden>
            <div class="progress-bar" id="repProgressBar" aria-hidden="true"></div>
          </div>
          <div class="rep-selection-group" id="repSelectionGroup" hidden>
            <div
              class="rep-selection"
              id="setSelectionSection"
              role="group"
              aria-labelledby="setCountLabel"
              hidden
            >
              <div class="rep-selection__label" id="setCountLabel">
                <span>Anzahl der S√§tze</span>
                <span class="rep-selection__value" id="setCountValue">0</span>
              </div>
              <input
                type="range"
                id="setCountSlider"
                min="1"
                step="1"
                value="1"
                aria-labelledby="setCountLabel"
              />
            </div>
            <div
              class="rep-selection"
              id="repSelectionSection"
              role="group"
              aria-labelledby="repCountLabel"
              hidden
            >
              <div class="rep-selection__label" id="repCountLabel">
                <span>Wiederholungen pro Satz</span>
                <span class="rep-selection__value" id="repCountValue">0</span>
              </div>
              <input
                type="range"
                id="repCountSlider"
                min="1"
                step="1"
                value="1"
                aria-labelledby="repCountLabel"
              />
            </div>
          </div>
        </section>
        <p id="sessionSummary" class="session-summary" hidden></p>
      </div>
      <div class="modal-actions">
        <div class="start-controls">
          <button id="sessionStartBtn" class="primary-button" type="button">Start</button>
          <label for="breakBellToggle" class="switch-labeled" id="breakBellControl">
            <span class="switch-label-text">Klangschale</span>
            <div class="switch">
              <input type="checkbox" id="breakBellToggle" />
              <span class="switch-track"><span class="switch-thumb"></span></span>
            </div>
            <span id="breakBellState" class="switch-state">Aus</span>
          </label>
        </div>
        <div id="sessionControls" class="session-controls" hidden>
          <button id="continueBtn" type="button" class="secondary-button" disabled>Weiter</button>
          <button id="pauseBtn" type="button" class="secondary-button" disabled>Pause</button>
          <button id="stopBtn" type="button" class="danger-button">Abbrechen</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="exerciseDetailsModal" hidden>
    <div
      class="modal-card"
      role="dialog"
      aria-modal="true"
      aria-labelledby="exerciseDetailsTitle"
      aria-describedby="exerciseDetailsInstruction"
    >
      <header class="modal-header">
        <div>
          <h2 id="exerciseDetailsTitle">√úbungsdetails</h2>
        </div>
        <button id="closeExerciseDetailsBtn" type="button" class="ghost-button ghost-button--small">
          Schlie√üen
        </button>
      </header>
      <div class="exercise-details-content">
        <p id="exerciseDetailsInstruction" class="exercise-details-instruction">
          Hier erscheinen die Details zur ausgew√§hlten √úbung.
        </p>
        <ul id="exerciseFacts" class="exercise-facts"></ul>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="debugModal" hidden>
    <div class="modal-card modal-card--narrow" role="dialog" aria-modal="true" aria-labelledby="debugModalTitle">
      <header class="modal-header">
        <h2 id="debugModalTitle">Debug Log</h2>
        <button id="closeDebugModal" type="button" class="ghost-button ghost-button--small">Schlie√üen</button>
      </header>
      <div id="debugPanel" class="debug-panel">
        <pre id="debugLog" class="debug-log">Noch keine Eintr√§ge.</pre>
      </div>
    </div>
  </div>

  <script src="./config.production.js"></script>
  <script>
    const countdownStepSelect = document.getElementById("countdownStepSelect");
    const viewStatsBtn = document.getElementById("viewStatsBtn");
    const exerciseEditorLink = document.getElementById("exerciseEditorLink");
    const openSessionBtn = document.getElementById("openSessionBtn");
    const beatsRadioBtn = document.getElementById("beatsRadioBtn");
    const mindfulnessPromptBtn = document.getElementById("mindfulnessPromptBtn");
    const debugLogBtn = document.getElementById("debugLogBtn");
    const exerciseModal = document.getElementById("exerciseModal");
    const sessionCloseBtn = document.getElementById("sessionCloseBtn");
    const exerciseModalTitle = document.getElementById("exerciseModalTitle");
    const exerciseFacts = document.getElementById("exerciseFacts");
    const sessionSummary = document.getElementById("sessionSummary");
    const streakIndicator = document.getElementById("streakIndicator");
    const streakCountEl = document.getElementById("streakCount");
    const streakLabelEl = document.getElementById("streakLabel");
    const sessionControls = document.getElementById("sessionControls");
    const exerciseOverviewSection = document.querySelector(".exercise-overview");
    const exerciseDetailsBtn = document.getElementById("exerciseDetailsBtn");
    const exerciseDetailsModal = document.getElementById("exerciseDetailsModal");
    const exerciseDetailsTitle = document.getElementById("exerciseDetailsTitle");
    const exerciseDetailsInstruction = document.getElementById("exerciseDetailsInstruction");
    const closeExerciseDetailsBtn = document.getElementById("closeExerciseDetailsBtn");
    const breakBellToggle = document.getElementById("breakBellToggle");
    const breakBellState = document.getElementById("breakBellState");
    const repSelectionGroup = document.getElementById("repSelectionGroup");
    const repSelectionSection = document.getElementById("repSelectionSection");
    const repCountSlider = document.getElementById("repCountSlider");
    const repCountValue = document.getElementById("repCountValue");
    const setSelectionSection = document.getElementById("setSelectionSection");
    const setCountSlider = document.getElementById("setCountSlider");
    const setCountValue = document.getElementById("setCountValue");

    const COUNTDOWN_MIN_MS = 100;
    const COUNTDOWN_MAX_MS = 1000;
    const COUNTDOWN_STEP_INCREMENT_MS = 100;
    let countdownStepMs = 200;
    let voiceMode = "auto";
    let exercises = [];
    let exercise = null;
    let selectedRepCount = null;
    let activeRepCount = null;
    let repSelectionExerciseId = null;
    let selectedSetCount = null;
    let activeSetCount = null;
    let setSelectionExerciseId = null;
    let mindfulnessPrompts = [];
    let mindfulnessPromptActive = false;
    let skipRequested = false;
    let aborted = false;
    let sessionRunning = false;
    let pauseRequested = false;
    let pauseAwaitingResume = false;
    let pauseResumeResolver = null;
    let pauseContext = null;
    const hasBrowserSpeech = "speechSynthesis" in window;
    let currentAudio = null;
    let currentAudioUrl = null;
    let currentFetchController = null;
    let remoteFailureNotified = false;
    let remoteBackoffActive = false;
    let remoteRetryAvailableAt = 0;
    let remoteFailureCount = 0;
    let lastRemoteBackoffLogAt = 0;
    let audioUnlockPromise = null;
    let sharedAudioElement = null;
    let sharedAudioContext = null;
    let audioContextUnlockPromise = null;
    let audioUnlocked = false;
    let lastAudioUnlockError = "";
    let visibleModalCount = 0;

    const display = document.getElementById("display");
    const startBtn = document.getElementById("sessionStartBtn");
    const continueBtn = document.getElementById("continueBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stopBtn = document.getElementById("stopBtn");
    const closeDebugModalBtn = document.getElementById("closeDebugModal");
    const debugModal = document.getElementById("debugModal");
    const select = document.getElementById("exerciseSelect");
    const statusMessage = document.getElementById("statusMessage");
    const voiceModeRadios = Array.from(document.querySelectorAll('input[name="voiceMode"]'));
    const debugPanel = document.getElementById("debugPanel");
    const debugLog = document.getElementById("debugLog");
    const debugEntries = [];
    const MEDIA_READY_STATE_LABELS = [
      "HAVE_NOTHING",
      "HAVE_METADATA",
      "HAVE_CURRENT_DATA",
      "HAVE_FUTURE_DATA",
      "HAVE_ENOUGH_DATA",
    ];
    const MEDIA_NETWORK_STATE_LABELS = [
      "NETWORK_EMPTY",
      "NETWORK_IDLE",
      "NETWORK_LOADING",
      "NETWORK_NO_SOURCE",
    ];
    const MEDIA_ERROR_CODE_LABELS = {
      1: "MEDIA_ERR_ABORTED",
      2: "MEDIA_ERR_NETWORK",
      3: "MEDIA_ERR_DECODE",
      4: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    };
    const repProgressContainer = document.getElementById("repProgressContainer");
    const repProgressBar = document.getElementById("repProgressBar");
    const DEBUG_MAX_ENTRIES = 12;
    const REMOTE_SPEECH_SLOW_THRESHOLD_MS = 1500;
    const REMOTE_RETRY_BASE_DELAY_MS = 4000;
    const REMOTE_RETRY_MAX_DELAY_MS = 60000;
    const REMOTE_BACKOFF_LOG_THROTTLE_MS = 3000;
    const SILENT_AUDIO_SRC =
      "data:audio/wav;base64,UklGRrQBAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YZABAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA";
    const BREAK_BELL_PROMPT_LEAD_MS = 2000;
    const MINDFULNESS_SPEECH_RATE = 0.9;
    const MINDFULNESS_PROMPT_DELAY_MS = 3000;
    let breakBellAudioElement = null;
    let breakBellAudioReadyPromise = null;

    const STREAK_THRESHOLD_SECONDS = 10 * 60;
    const STREAK_ROLLING_WINDOW_DAYS = 7;
    const STREAK_MIN_ACTIVE_DAYS = 4;
    const STREAK_MAX_SKIPS_PER_WINDOW = STREAK_ROLLING_WINDOW_DAYS - STREAK_MIN_ACTIVE_DAYS;
    const STREAK_FETCH_TIMEOUT_MS = 8000;
    const TIME_KEYS = [
      "completedAt",
      "completed_at",
      "finishedAt",
      "finished_at",
      "timestamp",
      "createdAt",
      "updatedAt",
      "time",
      "date",
    ];
    const DURATION_KEYS = [
      "durationMs",
      "duration_ms",
      "durationMilliseconds",
      "duration_milliseconds",
      "duration",
      "durationSeconds",
      "duration_seconds",
    ];
    let streakFetchInFlight = null;

    const now = () => (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now());

    const speechConfig = window.STRETCH_COACH_CONFIG || {};
    const preferredVoice = speechConfig.voiceId ? String(speechConfig.voiceId) : null;
    const SPEECH_API_ENDPOINT = determineSpeechEndpoint(speechConfig);
    const PROGRESS_API_ENDPOINT = determineProgressEndpoint(speechConfig);
    const CLIENT_ID_STORAGE_KEY = "stretchCoachClientId";
    const COMPLETION_REQUEST_TIMEOUT_MS = 8000;
    let cachedClientId = null;

    if (exerciseEditorLink) {
      const editorUrlFromConfig =
        speechConfig && typeof speechConfig.exerciseEditorUrl === "string"
          ? speechConfig.exerciseEditorUrl.trim()
          : "";
      if (editorUrlFromConfig) {
        exerciseEditorLink.href = editorUrlFromConfig;
        if (/^https?:/i.test(editorUrlFromConfig)) {
          exerciseEditorLink.target = "_blank";
          exerciseEditorLink.rel = "noopener noreferrer";
        }
      }
    }

    function stripTrailingSlash(value) {
      return value.replace(/\/+$/, "");
    }

    function determineSpeechEndpoint(config) {
      if (config && config.speechApiUrl) {
        const normalized = stripTrailingSlash(String(config.speechApiUrl));
        return normalized || "/api/speak";
      }
      if (config && config.speechApiBaseUrl) {
        const normalizedBase = stripTrailingSlash(String(config.speechApiBaseUrl));
        return normalizedBase ? `${normalizedBase}/api/speak` : "/api/speak";
      }
      return "/api/speak";
    }

    function determineProgressEndpoint(config) {
      if (config && typeof config.progressApiUrl === "string") {
        const trimmed = config.progressApiUrl.trim();
        if (!trimmed) {
          return "/api/exercise-completions";
        }
        const normalized = stripTrailingSlash(trimmed);
        return normalized || "/api/exercise-completions";
      }
      if (config && config.progressApiUrl === null) {
        return null;
      }
      if (config && typeof config.progressApiBaseUrl === "string") {
        const trimmedBase = config.progressApiBaseUrl.trim();
        if (!trimmedBase) {
          return "/api/exercise-completions";
        }
        const normalizedBase = stripTrailingSlash(trimmedBase);
        return normalizedBase
          ? `${normalizedBase}/api/exercise-completions`
          : "/api/exercise-completions";
      }
      return "/api/exercise-completions";
    }

    function parseDateValue(value) {
      if (!value && value !== 0) {
        return null;
      }
      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value;
      }
      if (typeof value === "number") {
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      if (typeof value === "string") {
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }
        const date = new Date(trimmed);
        return Number.isNaN(date.getTime()) ? null : date;
      }
      return null;
    }

    function getCompletionDate(entry) {
      if (!entry || typeof entry !== "object") {
        return null;
      }
      for (const key of TIME_KEYS) {
        if (entry[key]) {
          const parsed = parseDateValue(entry[key]);
          if (parsed) {
            return parsed;
          }
        }
      }
      if (entry.completed_at) {
        return parseDateValue(entry.completed_at);
      }
      if (entry.finished_at) {
        return parseDateValue(entry.finished_at);
      }
      return null;
    }

    function getStartOfDay(date) {
      const result = new Date(date);
      result.setHours(0, 0, 0, 0);
      return result;
    }

    function getDurationSeconds(entry) {
      if (!entry || typeof entry !== "object") {
        return 0;
      }
      for (const key of DURATION_KEYS) {
        if (!(key in entry)) {
          continue;
        }
        const value = entry[key];
        if (value === null || value === undefined) {
          continue;
        }
        if (typeof value === "number" && Number.isFinite(value)) {
          return key.toLowerCase().includes("ms") ? value / 1000 : value;
        }
        if (typeof value === "string") {
          const normalized = value.trim();
          if (!normalized) {
            continue;
          }
          const parsed = Number(normalized);
          if (Number.isFinite(parsed)) {
            return key.toLowerCase().includes("ms") ? parsed / 1000 : parsed;
          }
        }
      }
      return 0;
    }

    function buildDailyDurationMap(entries) {
      const dailyDurations = new Map();
      let earliestDate = null;
      for (const entry of entries) {
        const completedAt = getCompletionDate(entry);
        if (!completedAt) {
          continue;
        }
        const durationSeconds = getDurationSeconds(entry);
        if (durationSeconds <= 0) {
          continue;
        }
        const day = getStartOfDay(completedAt);
        if (!earliestDate || day < earliestDate) {
          earliestDate = day;
        }
        const key = day.toISOString().slice(0, 10);
        const existing = dailyDurations.get(key) || 0;
        dailyDurations.set(key, existing + durationSeconds);
      }
      return { dailyDurations, earliestDate };
    }

    function computeStreakStats(entries) {
      const { dailyDurations, earliestDate } = buildDailyDurationMap(entries);
      if (!earliestDate) {
        return {
          currentStreak: 0,
          bestStreak: 0,
          allowedSkipsRemaining: STREAK_MAX_SKIPS_PER_WINDOW,
          lastResetDate: null,
          hasSuccessfulDay: false,
        };
      }

      const today = getStartOfDay(new Date());
      const startDate = getStartOfDay(earliestDate);
      const totalDays = Math.max(1, Math.floor((today - startDate) / 86400000) + 1);

      let currentStreak = 0;
      let bestStreak = 0;
      let lastResetDate = null;
      let hasSuccessfulDay = false;

      const windowStatuses = [];
      let trainingDaysInWindow = 0;
      let restDaysInWindow = 0;

      for (let offset = 0; offset < totalDays; offset += 1) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + offset);

        const key = date.toISOString().slice(0, 10);
        const durationSeconds = dailyDurations.get(key) || 0;
        const isSuccess = durationSeconds >= STREAK_THRESHOLD_SECONDS;

        const isToday = date.getTime() === today.getTime();
        const isPending = isToday && !isSuccess;
        const windowStatus = isSuccess ? "success" : isPending ? "pending" : "rest";

        windowStatuses.push({ status: windowStatus, date: new Date(date) });
        if (windowStatus === "success") {
          trainingDaysInWindow += 1;
        } else if (windowStatus === "rest") {
          restDaysInWindow += 1;
        }

        while (windowStatuses.length > STREAK_ROLLING_WINDOW_DAYS) {
          const removed = windowStatuses.shift();
          if (removed?.status === "success") {
            trainingDaysInWindow -= 1;
          } else if (removed?.status === "rest") {
            restDaysInWindow -= 1;
          }
        }

        if (windowStatus !== "pending" && restDaysInWindow > STREAK_MAX_SKIPS_PER_WINDOW) {
          lastResetDate = new Date(date);
          if (windowStatus === "success") {
            currentStreak = 1;
            windowStatuses.length = 0;
            windowStatuses.push({ status: "success", date: new Date(date) });
            trainingDaysInWindow = 1;
            restDaysInWindow = 0;
            hasSuccessfulDay = true;
          } else {
            currentStreak = 0;
            windowStatuses.length = 0;
            windowStatuses.push({ status: "rest", date: new Date(date) });
            trainingDaysInWindow = 0;
            restDaysInWindow = 1;
          }
        } else if (windowStatus === "success") {
          currentStreak += 1;
          hasSuccessfulDay = true;
        }

        bestStreak = Math.max(bestStreak, currentStreak);
      }

      const restDaysForAllowance = windowStatuses.filter(
        entry => entry.status === "rest" && entry.date.getTime() !== today.getTime(),
      ).length;

      const rawAllowedSkips = Math.max(
        0,
        STREAK_MAX_SKIPS_PER_WINDOW - restDaysForAllowance,
      );
      const allowedSkipsRemaining = hasSuccessfulDay
        ? rawAllowedSkips
        : STREAK_MAX_SKIPS_PER_WINDOW;

      return {
        currentStreak,
        bestStreak,
        allowedSkipsRemaining,
        lastResetDate,
        hasSuccessfulDay,
      };
    }

    function collectMindfulnessPrompts(source, result) {
      if (!source) {
        return result;
      }
      if (Array.isArray(source)) {
        for (const entry of source) {
          collectMindfulnessPrompts(entry, result);
        }
        return result;
      }
      if (typeof source === "object") {
        for (const value of Object.values(source)) {
          collectMindfulnessPrompts(value, result);
        }
        return result;
      }
      if (typeof source === "string") {
        const trimmed = source.trim();
        if (trimmed) {
          result.push(trimmed);
        }
      }
      return result;
    }

    function flattenMindfulnessPrompts(data) {
      const buffer = [];
      collectMindfulnessPrompts(data, buffer);
      return buffer;
    }

    function getRandomMindfulnessPrompt() {
      if (!Array.isArray(mindfulnessPrompts) || mindfulnessPrompts.length === 0) {
        return null;
      }
      const index = Math.floor(Math.random() * mindfulnessPrompts.length);
      return mindfulnessPrompts[index] ?? null;
    }

    async function playStandaloneMindfulnessPrompt(prompt) {
      if (!prompt) {
        return;
      }

      appendDebug("Achtsamkeitsspruch (Startseite) gestartet.");
      setStatus("Ein Moment der Achtsamkeit beginnt...", "info");

      try {
        await playBreakBellCue();
        await new Promise(resolve => setTimeout(resolve, MINDFULNESS_PROMPT_DELAY_MS));

        if (sessionRunning) {
          appendDebug("Achtsamkeitsspruch (Startseite) abgebrochen, Training gestartet.");
          setStatus("Achtsamkeitsspruch √ºbersprungen, da ein Training gestartet wurde.", "warn");
          return;
        }

        setStatus(prompt, "info");
        await speak(prompt, { voiceId: "Daniel", rate: MINDFULNESS_SPEECH_RATE });
        appendDebug("Achtsamkeitsspruch (Startseite) beendet.");
      } catch (error) {
        console.error("Fehler beim Abspielen des Achtsamkeitsspruchs", error);
        appendDebug(
          "Achtsamkeitsspruch (Startseite) fehlgeschlagen.",
          describeError(error)
        );
        setStatus("Achtsamkeitsspruch konnte nicht abgespielt werden.", "error");
      }
    }

    function setStatus(message = "", type = "info") {
      if (!statusMessage) return;
      if (!message) {
        statusMessage.textContent = "";
        statusMessage.hidden = true;
        statusMessage.removeAttribute("data-type");
        return;
      }
      statusMessage.hidden = false;
      statusMessage.textContent = message;
      statusMessage.setAttribute("data-type", type);
    }

    function appendDebug(message, details = "") {
      const timestamp = new Date().toLocaleTimeString();
      let entry = `[${timestamp}] ${message}`;
      if (details) {
        entry += `\n${details}`;
      }
      debugEntries.push(entry);
      while (debugEntries.length > DEBUG_MAX_ENTRIES) {
        debugEntries.shift();
      }
      refreshDebugLog();
    }

    function refreshDebugLog() {
      if (!debugLog) return;
      if (!debugEntries.length) {
        debugLog.textContent = "Noch keine Eintr√§ge.";
        return;
      }
      debugLog.textContent = debugEntries.join("\n\n");
    }

    async function refreshStreakIndicator() {
      if (!streakIndicator || !streakCountEl || !streakLabelEl) {
        return;
      }
      if (!PROGRESS_API_ENDPOINT) {
        streakIndicator.hidden = true;
        return;
      }
      if (streakFetchInFlight) {
        try {
          await streakFetchInFlight;
        } catch (_err) {
          // Fehler wurde bereits protokolliert.
        }
        return;
      }

      const fetchPromise = (async () => {
        const controller = new AbortController();
        const timeoutId = window.setTimeout(
          () => controller.abort(),
          STREAK_FETCH_TIMEOUT_MS,
        );

        try {
          const response = await fetch(PROGRESS_API_ENDPOINT, { signal: controller.signal });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          let entries = [];
          if (Array.isArray(data)) {
            entries = data;
          } else if (data && Array.isArray(data.items)) {
            entries = data.items;
          } else if (data && Array.isArray(data.data)) {
            entries = data.data;
          }
          if (!Array.isArray(entries)) {
            entries = [];
          }

          const { currentStreak, allowedSkipsRemaining, hasSuccessfulDay } =
            computeStreakStats(entries);

          const labelText = currentStreak === 1 ? "Tag am St√ºck" : "Tage am St√ºck";
          streakCountEl.textContent = String(currentStreak);
          streakLabelEl.textContent = labelText;

          const tooltipParts = [
            "Mindestens 4 Trainingstage in 7 Tagen halten den Streak am Leben.",
          ];
          if (hasSuccessfulDay) {
            if (allowedSkipsRemaining > 0) {
              tooltipParts.push(
                allowedSkipsRemaining === 1
                  ? "Noch 1 freier Pausentag im aktuellen 7-Tage-Fenster."
                  : `Noch ${allowedSkipsRemaining} freie Pausentage im aktuellen 7-Tage-Fenster.`,
              );
            } else {
              tooltipParts.push("Derzeit kein freier Pausentag im 7-Tage-Fenster √ºbrig.");
            }
          } else {
            tooltipParts.push(
              "Trainiere an vier Tagen innerhalb von sieben, um deinen Streak aufzubauen.",
            );
          }
          streakIndicator.title = tooltipParts.join(" ");

          streakIndicator.hidden = false;
        } catch (error) {
          if (controller.signal.aborted) {
            appendDebug("Streak-Aktualisierung abgebrochen (Timeout).");
          } else {
            appendDebug("Streak-Aktualisierung fehlgeschlagen.", describeError(error));
          }
          streakIndicator.hidden = true;
        } finally {
          window.clearTimeout(timeoutId);
          streakFetchInFlight = null;
        }
      })();

      streakFetchInFlight = fetchPromise;
      try {
        await fetchPromise;
      } catch (_err) {
        // Fehler wurde bereits protokolliert.
      }
    }

    function buildMediaDebugDetails({ audio = null, error = null, reason = "" } = {}) {
      const lines = [];
      if (reason) {
        lines.push(`Grund: ${reason}`);
      }
      if (error) {
        lines.push(`Fehler: ${describeError(error)}`);
        if (error && typeof error === "object") {
          if (error.name && error.name !== "Error") {
            lines.push(`Fehlertyp: ${error.name}`);
          }
          if (typeof error.code !== "undefined" && error.code !== null) {
            const label = MEDIA_ERROR_CODE_LABELS[error.code] || "unbekannt";
            lines.push(`Fehlercode: ${error.code}${label ? ` (${label})` : ""}`);
          }
        }
      }

      if (audio) {
        try {
          const readyStateLabel = MEDIA_READY_STATE_LABELS[audio.readyState] || "unbekannt";
          const networkStateLabel = MEDIA_NETWORK_STATE_LABELS[audio.networkState] || "unbekannt";
          const src = audio.currentSrc || audio.src || "";
          lines.push(`readyState=${audio.readyState} (${readyStateLabel})`);
          lines.push(`networkState=${audio.networkState} (${networkStateLabel})`);
          lines.push(`currentSrc=${src || "<leer>"}`);
          lines.push(`preload=${audio.preload || "<leer>"}`);
          lines.push(`autoplay=${!!audio.autoplay}`);
          lines.push(`muted=${audio.muted}`);
          lines.push(`volume=${audio.volume}`);
          lines.push(`paused=${audio.paused}`);
          lines.push(`ended=${audio.ended}`);
        } catch (stateError) {
          lines.push(`Konnte Audio-Status nicht ermitteln: ${describeError(stateError)}`);
        }

        const mediaError = audio.error;
        if (mediaError) {
          if (typeof mediaError.code !== "undefined") {
            const mediaErrorLabel = MEDIA_ERROR_CODE_LABELS[mediaError.code] || "unbekannt";
            lines.push(
              `mediaError.code=${mediaError.code}${
                mediaErrorLabel ? ` (${mediaErrorLabel})` : ""
              }`
            );
          }
          if (mediaError.message) {
            lines.push(`mediaError.message=${mediaError.message}`);
          }
        }
      } else {
        lines.push("Audio-Element nicht verf√ºgbar.");
      }

      return lines.join("\n");
    }

    function setModalVisibility(modal, visible) {
      if (!modal) return;
      const currentlyVisible = !modal.hidden;
      if (visible === currentlyVisible) {
        return;
      }
      modal.hidden = !visible;
      modal.setAttribute("aria-hidden", visible ? "false" : "true");
      visibleModalCount += visible ? 1 : -1;
      if (visibleModalCount < 0) {
        visibleModalCount = 0;
      }
      if (typeof document !== "undefined" && document.body) {
        if (visibleModalCount > 0) {
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = "";
        }
      }
    }

    function openModal(modal) {
      setModalVisibility(modal, true);
    }

    function closeModal(modal) {
      setModalVisibility(modal, false);
    }

    function formatFact(label, value, suffix = "") {
      return `${label}: ${value}${suffix}`;
    }

    function refreshRepSelectionGroupVisibility() {
      if (!repSelectionGroup) return;
      const repVisible = !!(repSelectionSection && !repSelectionSection.hidden);
      const setVisible = !!(setSelectionSection && !setSelectionSection.hidden);
      repSelectionGroup.hidden = !(repVisible || setVisible);
    }

    function refreshBreakBellStateLabel() {
      if (!breakBellState) return;
      const isEnabled = !!(breakBellToggle && breakBellToggle.checked);
      breakBellState.textContent = isEnabled ? "An" : "Aus";
    }

    function parseBreakBellDefault(ex) {
      if (!ex || typeof ex.break_bell !== "string") {
        return false;
      }
      return ex.break_bell.trim().toLowerCase() === "yes";
    }

    function applyBreakBellPreset(ex) {
      if (!breakBellToggle) return;
      const shouldEnable = parseBreakBellDefault(ex);
      breakBellToggle.checked = shouldEnable;
      refreshBreakBellStateLabel();
    }

    function isBreakBellEnabled() {
      return !!(breakBellToggle && breakBellToggle.checked);
    }

    function parseExerciseRepCount(ex) {
      if (!ex) {
        return null;
      }
      const raw = Number(ex.duration);
      if (!Number.isFinite(raw)) {
        return null;
      }
      const value = Math.trunc(raw);
      return value > 0 ? value : null;
    }

    function parseExerciseSetCount(ex) {
      if (!ex) {
        return null;
      }
      const raw = Number(ex.sets);
      if (!Number.isFinite(raw)) {
        return null;
      }
      const value = Math.trunc(raw);
      return value > 0 ? value : null;
    }

    function refreshRepSelectionLabel(current, max) {
      if (!repCountValue) return;
      if (Number.isInteger(max) && max > 0) {
        repCountValue.textContent = `${current} von ${max}`;
      } else {
        repCountValue.textContent = `${current}`;
      }
    }

    function refreshSetSelectionLabel(current, max) {
      if (!setCountValue) return;
      if (Number.isInteger(max) && max > 0) {
        setCountValue.textContent = `${current} von ${max}`;
      } else {
        setCountValue.textContent = `${current}`;
      }
    }

    function setRepSelectionDisabled(disabled) {
      if (repCountSlider) {
        repCountSlider.disabled = !!disabled;
      }
      if (repSelectionSection) {
        repSelectionSection.dataset.disabled = disabled ? "true" : "false";
      }
    }

    function setSetSelectionDisabled(disabled) {
      if (setCountSlider) {
        setCountSlider.disabled = !!disabled;
      }
      if (setSelectionSection) {
        setSelectionSection.dataset.disabled = disabled ? "true" : "false";
      }
    }

    function updateRepSelection(ex, { resetToDefault = false } = {}) {
      if (!repSelectionSection || !repCountSlider || !repCountValue) {
        selectedRepCount = null;
        repSelectionExerciseId = null;
        refreshRepSelectionGroupVisibility();
        return;
      }

      const exerciseId = ex && ex.id ? String(ex.id) : null;
      const defaultCount = parseExerciseRepCount(ex);

      if (!defaultCount) {
        repSelectionSection.hidden = true;
        selectedRepCount = null;
        repSelectionExerciseId = exerciseId;
        activeRepCount = null;
        setRepSelectionDisabled(true);
        refreshRepSelectionGroupVisibility();
        return;
      }

      repSelectionSection.hidden = false;
      repCountSlider.min = "1";
      repCountSlider.max = String(defaultCount);
      repCountSlider.step = "1";

      const isDifferentExercise = exerciseId !== repSelectionExerciseId;
      repSelectionExerciseId = exerciseId;

      const shouldReset =
        resetToDefault ||
        isDifferentExercise ||
        !Number.isInteger(selectedRepCount) ||
        selectedRepCount < 1;

      let value = shouldReset
        ? defaultCount
        : Math.max(1, Math.min(selectedRepCount, defaultCount));

      selectedRepCount = value;
      repCountSlider.value = String(value);
      setRepSelectionDisabled(sessionRunning);
      refreshRepSelectionLabel(value, defaultCount);
      refreshRepSelectionGroupVisibility();
    }

    function updateSetSelection(ex, { resetToDefault = false } = {}) {
      if (!setSelectionSection || !setCountSlider || !setCountValue) {
        selectedSetCount = null;
        setSelectionExerciseId = null;
        refreshRepSelectionGroupVisibility();
        return;
      }

      const exerciseId = ex && ex.id ? String(ex.id) : null;
      const defaultCount = parseExerciseSetCount(ex);

      if (!defaultCount) {
        setSelectionSection.hidden = true;
        selectedSetCount = null;
        setSelectionExerciseId = exerciseId;
        activeSetCount = null;
        setSetSelectionDisabled(true);
        refreshRepSelectionGroupVisibility();
        return;
      }

      setSelectionSection.hidden = false;
      setCountSlider.min = "1";
      setCountSlider.max = String(defaultCount);
      setCountSlider.step = "1";

      const isDifferentExercise = exerciseId !== setSelectionExerciseId;
      setSelectionExerciseId = exerciseId;

      const shouldReset =
        resetToDefault ||
        isDifferentExercise ||
        !Number.isInteger(selectedSetCount) ||
        selectedSetCount < 1;

      let value = shouldReset
        ? defaultCount
        : Math.max(1, Math.min(selectedSetCount, defaultCount));

      selectedSetCount = value;
      setCountSlider.value = String(value);
      setSetSelectionDisabled(sessionRunning);
      refreshSetSelectionLabel(value, defaultCount);
      refreshRepSelectionGroupVisibility();
    }

    function getConfiguredRepCount(ex) {
      const defaultCount = parseExerciseRepCount(ex);
      if (!defaultCount) {
        return 0;
      }
      const sliderValue = repCountSlider ? Number(repCountSlider.value) : NaN;
      if (Number.isInteger(sliderValue) && sliderValue >= 1) {
        return Math.max(1, Math.min(sliderValue, defaultCount));
      }
      if (Number.isInteger(selectedRepCount) && selectedRepCount >= 1) {
        return Math.max(1, Math.min(selectedRepCount, defaultCount));
      }
      return defaultCount;
    }

    function getConfiguredSetCount(ex) {
      const defaultCount = parseExerciseSetCount(ex);
      if (!defaultCount) {
        return 0;
      }
      const sliderValue = setCountSlider ? Number(setCountSlider.value) : NaN;
      if (Number.isInteger(sliderValue) && sliderValue >= 1) {
        return Math.max(1, Math.min(sliderValue, defaultCount));
      }
      if (Number.isInteger(selectedSetCount) && selectedSetCount >= 1) {
        return Math.max(1, Math.min(selectedSetCount, defaultCount));
      }
      return defaultCount;
    }

    function getSessionRepCount() {
      const defaultCount = parseExerciseRepCount(exercise);
      if (Number.isInteger(activeRepCount) && activeRepCount > 0) {
        return activeRepCount;
      }
      if (Number.isInteger(selectedRepCount) && selectedRepCount > 0 && defaultCount) {
        return Math.max(1, Math.min(selectedRepCount, defaultCount));
      }
      return defaultCount || 0;
    }

    function getSessionSetCount() {
      const defaultCount = parseExerciseSetCount(exercise);
      if (Number.isInteger(activeSetCount) && activeSetCount > 0) {
        const limit = Number.isInteger(defaultCount) && defaultCount > 0 ? defaultCount : activeSetCount;
        return Math.max(1, Math.min(activeSetCount, limit));
      }
      if (Number.isInteger(selectedSetCount) && selectedSetCount > 0 && defaultCount) {
        return Math.max(1, Math.min(selectedSetCount, defaultCount));
      }
      return defaultCount || 0;
    }

    function updateExerciseOverview(
      ex,
      { resetRepSelection = false, resetSetSelection = false } = {}
    ) {
      updateSetSelection(ex, { resetToDefault: resetSetSelection });
      updateRepSelection(ex, { resetToDefault: resetRepSelection });
      if (exerciseModalTitle) {
        exerciseModalTitle.textContent = ex && ex.name ? ex.name : "√úbung";
      }
      if (exerciseDetailsTitle) {
        exerciseDetailsTitle.textContent = ex && ex.name ? ex.name : "√úbungsdetails";
      }
      if (exerciseDetailsInstruction) {
        if (ex && ex.instruction) {
          const instructionText = String(ex.instruction).trim();
          const exerciseName = ex.name ? String(ex.name).trim() : "";
          if (
            exerciseName &&
            instructionText.toLowerCase().startsWith(exerciseName.toLowerCase())
          ) {
            const withoutName = instructionText
              .slice(exerciseName.length)
              .replace(/^[\s.:,-]+/, "")
              .trim();
            exerciseDetailsInstruction.textContent = withoutName || instructionText;
          } else {
            exerciseDetailsInstruction.textContent = instructionText;
          }
        } else {
          exerciseDetailsInstruction.textContent = "Keine Beschreibung vorhanden.";
        }
      }
      if (exerciseDetailsBtn) {
        exerciseDetailsBtn.disabled = !ex;
      }
      if (breakBellToggle && typeof ex !== "undefined" && ex !== null) {
        // Keep current toggle unless exercise changed via preset elsewhere
        refreshBreakBellStateLabel();
      }
      if (exerciseFacts) {
        if (!ex) {
          exerciseFacts.innerHTML = "";
        } else {
          const factItems = [];
          const hasSets = Number.isInteger(ex.sets);
          const hasDuration = Number.isInteger(ex.duration);
          if (!(hasSets && hasDuration)) {
            if (hasSets) {
              factItems.push(formatFact("S√§tze", ex.sets));
            }
            if (hasDuration) {
              factItems.push(formatFact("Wiederholungen pro Satz", ex.duration));
            }
          }
          if (Number.isFinite(ex.rep_time)) {
            factItems.push(formatFact("Dauer je Wiederholung", ex.rep_time, " Sekunden"));
          }
          if (Number.isFinite(ex.prep_time)) {
            factItems.push(formatFact("Vorbereitungszeit", ex.prep_time, " Sekunden"));
          }
          if (Number.isFinite(ex.rest_time)) {
            factItems.push(formatFact("Pause zwischen den S√§tzen", ex.rest_time, " Sekunden"));
          }
          exerciseFacts.innerHTML = factItems.map(item => `<li>${item}</li>`).join("");
        }
      }
    }

    function getBreakBellAudioElement() {
      if (!breakBellAudioElement) {
        breakBellAudioElement = new Audio("./klangschale.mp3");
        breakBellAudioElement.preload = "auto";
        breakBellAudioElement.playsInline = true;
      }
      return breakBellAudioElement;
    }

    async function ensureBreakBellAudioReady() {
      const audio = getBreakBellAudioElement();
      if (audio.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
        return audio;
      }
      if (!breakBellAudioReadyPromise) {
        breakBellAudioReadyPromise = new Promise((resolve, reject) => {
          const cleanup = () => {
            audio.removeEventListener("canplaythrough", onReady);
            audio.removeEventListener("loadeddata", onReady);
            audio.removeEventListener("error", onError);
          };

          const onReady = () => {
            cleanup();
            breakBellAudioReadyPromise = null;
            resolve(audio);
          };

          const onError = () => {
            cleanup();
            const error = audio.error || new Error("Klangschale konnte nicht geladen werden.");
            breakBellAudioReadyPromise = null;
            reject(error);
          };

          audio.addEventListener("canplaythrough", onReady, { once: true });
          audio.addEventListener("loadeddata", onReady, { once: true });
          audio.addEventListener("error", onError, { once: true });

          try {
            audio.load();
          } catch (_err) {
            // ignore load errors
          }
        });
      }

      try {
        return await breakBellAudioReadyPromise;
      } catch (error) {
        breakBellAudioReadyPromise = null;
        throw error;
      }
    }

    async function playBreakBellCue() {
      const unlocked = await ensureAudioUnlocked().catch(() => false);
      if (!unlocked) {
        const baseReason =
          lastAudioUnlockError ||
          "Audiowiedergabe ist nicht freigeschaltet. Nutzerinteraktion erforderlich.";
        const reason = `${baseReason} (audioUnlocked=${audioUnlocked})`;
        const audioElement =
          typeof Audio !== "undefined"
            ? breakBellAudioElement || getBreakBellAudioElement()
            : null;
        appendDebug(
          "Klangschale konnte nicht abgespielt werden.",
          buildMediaDebugDetails({
            audio: audioElement,
            reason,
          })
        );
        return;
      }

      try {
        const audio = await ensureBreakBellAudioReady();
        try {
          audio.pause();
        } catch (_err) {
          // ignore pause errors
        }
        try {
          audio.currentTime = 0;
        } catch (_err) {
          // ignore reset errors
        }
        audio.muted = false;
        const playPromise = audio.play();
        if (playPromise && typeof playPromise.then === "function") {
          await playPromise;
        }
      } catch (error) {
        const audioForDebug =
          typeof Audio !== "undefined"
            ? breakBellAudioElement || getBreakBellAudioElement()
            : null;
        appendDebug(
          "Klangschale konnte nicht abgespielt werden.",
          buildMediaDebugDetails({
            audio: audioForDebug,
            error,
            reason: "Wiedergabe fehlgeschlagen",
          })
        );
      }
    }

    function resetProgress() {
      if (!repProgressContainer || !repProgressBar) return;
      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      repProgressContainer.hidden = true;
    }

    function resetSessionUI() {
      sessionRunning = false;
      skipRequested = false;
      aborted = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      if (startBtn) {
        startBtn.hidden = false;
        startBtn.disabled = false;
        startBtn.textContent = "Start";
      }
      if (sessionControls) {
        sessionControls.hidden = true;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = false;
      }
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (stopBtn) {
        stopBtn.disabled = true;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = false;
        sessionCloseBtn.disabled = false;
      }
      if (sessionSummary) {
        sessionSummary.hidden = true;
        sessionSummary.textContent = "";
      }
      resetProgress();
      activeRepCount = null;
      activeSetCount = null;
      setRepSelectionDisabled(false);
      setSetSelectionDisabled(false);
      updateSetSelection(exercise, { resetToDefault: false });
      updateRepSelection(exercise, { resetToDefault: false });
      if (display) {
        const preview = buildInstructionSpeech(exercise);
        display.textContent = preview || (exercise && exercise.name ? exercise.name : "Bereit?");
      }
    }

    function startSessionUI() {
      sessionRunning = true;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      const defaultRepCount = parseExerciseRepCount(exercise);
      const defaultSetCount = parseExerciseSetCount(exercise);
      activeRepCount = getConfiguredRepCount(exercise);
      activeSetCount = getConfiguredSetCount(exercise);
      if (activeRepCount > 0) {
        selectedRepCount = activeRepCount;
      }
      if (activeSetCount > 0) {
        selectedSetCount = activeSetCount;
      }
      if (repCountSlider && activeRepCount > 0) {
        repCountSlider.value = String(activeRepCount);
      }
      if (setCountSlider && activeSetCount > 0) {
        setCountSlider.value = String(activeSetCount);
      }
      setRepSelectionDisabled(true);
      setSetSelectionDisabled(true);
      if (defaultRepCount) {
        refreshRepSelectionLabel(activeRepCount > 0 ? activeRepCount : defaultRepCount, defaultRepCount);
      }
      if (defaultSetCount) {
        refreshSetSelectionLabel(activeSetCount > 0 ? activeSetCount : defaultSetCount, defaultSetCount);
      }
      resetProgress();
      if (startBtn) {
        startBtn.disabled = true;
        startBtn.hidden = true;
      }
      if (sessionControls) {
        sessionControls.hidden = false;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = true;
      }
      if (pauseBtn) {
        pauseBtn.disabled = false;
      }
      if (stopBtn) {
        stopBtn.disabled = false;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = true;
      }
      if (sessionSummary) {
        sessionSummary.hidden = true;
        sessionSummary.textContent = "";
      }
    }

    function finishSessionUI({ completed }) {
      sessionRunning = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;
      pauseContext = null;
      if (sessionControls) {
        sessionControls.hidden = true;
      }
      resetProgress();
      activeRepCount = null;
      activeSetCount = null;
      setRepSelectionDisabled(false);
      setSetSelectionDisabled(false);
      updateSetSelection(exercise, { resetToDefault: false });
      updateRepSelection(exercise, { resetToDefault: false });
      if (startBtn) {
        startBtn.hidden = false;
        startBtn.disabled = false;
        startBtn.textContent = completed ? "Nochmals starten" : "Erneut starten";
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      if (exerciseOverviewSection) {
        exerciseOverviewSection.hidden = false;
      }
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (stopBtn) {
        stopBtn.disabled = true;
      }
      if (sessionCloseBtn) {
        sessionCloseBtn.hidden = false;
        sessionCloseBtn.disabled = false;
      }
      if (sessionSummary) {
        sessionSummary.textContent = completed
          ? "Geschafft! Du hast die √úbung abgeschlossen."
          : "√úbung abgebrochen.";
        sessionSummary.hidden = false;
      }
    }

    function resolvePauseAwaiting() {
      pauseRequested = false;
      if (pauseResumeResolver) {
        const resolver = pauseResumeResolver;
        pauseResumeResolver = null;
        pauseAwaitingResume = false;
        pauseContext = null;
        try {
          resolver();
        } catch (_err) {
          // ignore resolve errors
        }
      } else {
        pauseAwaitingResume = false;
        pauseContext = null;
      }
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
    }

    async function handlePauseIfNeeded() {
      if (!pauseRequested || aborted) {
        pauseRequested = false;
        return;
      }
      pauseRequested = false;
      pauseAwaitingResume = true;
      pauseContext = "default";
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      appendDebug("Pause aktiviert.");
      if (display) {
        display.textContent = "Pause aktiv!";
      }
      await speak("Pause aktiv!");
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      await new Promise(resolve => {
        pauseResumeResolver = resolve;
      });
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
    }

    async function handleCountdownPause() {
      if (!pauseRequested || aborted) {
        pauseRequested = false;
        return;
      }
      pauseRequested = false;
      pauseAwaitingResume = true;
      pauseContext = "countdown";
      if (pauseBtn) {
        pauseBtn.disabled = true;
      }
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      appendDebug("Countdown wird angehalten.");
      if (display) {
        display.textContent = "Countdown angehalten";
      }
      await speak("Countdown angehalten");
      if (continueBtn) {
        continueBtn.disabled = false;
        continueBtn.textContent = "Fortsetzen";
      }
      await new Promise(resolve => {
        pauseResumeResolver = resolve;
      });
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
    }

    async function resumeFromPause() {
      if (!pauseAwaitingResume) return;
      pauseAwaitingResume = false;
      const resolver = pauseResumeResolver;
      pauseResumeResolver = null;
      if (continueBtn) {
        continueBtn.disabled = true;
        continueBtn.textContent = "Weiter";
      }
      appendDebug("Pause wird beendet.");
      if (pauseContext === "countdown") {
        pauseContext = null;
        if (display) {
          display.textContent = "Countdown wird fortgesetzt";
        }
        await speak("Countdown wird fortgesetzt");
      } else {
        if (display) {
          display.textContent = "Pause endet in 10 Sekunden";
        }
        await speak("Pause Ende in 10 Sekunden");
        await countdown(10, "", "");
        pauseContext = null;
      }
      if (pauseBtn && !aborted) {
        pauseBtn.disabled = false;
      }
      if (typeof resolver === "function") {
        resolver();
      }
    }

    async function waitWithPauseSupport(durationMs, options = {}) {
      let remaining = Math.max(0, Number(durationMs) || 0);
      if (remaining <= 0) {
        return;
      }
      const onResume = typeof options.onResume === "function" ? options.onResume : null;
      while (remaining > 0 && !aborted) {
        if (pauseRequested) {
          await handlePauseIfNeeded();
          if (aborted) {
            return;
          }
          if (onResume) {
            try {
              onResume();
            } catch (error) {
              console.error("Fehler beim Wiederherstellen der Pausenanzeige", error);
            }
          }
        }
        const step = Math.min(remaining, 250);
        await new Promise(resolve => setTimeout(resolve, step));
        if (aborted) {
          return;
        }
        remaining -= step;
      }
    }

    function describeError(error) {
      if (!error) return "Unbekannter Fehler";
      if (error instanceof Error) {
        const name = error.name && error.name !== "Error" ? `${error.name}: ` : "";
        return `${name}${error.message || String(error)}`;
      }
      if (typeof error === "object") {
        try {
          return JSON.stringify(error);
        } catch (_err) {
          return String(error);
        }
      }
      return String(error);
    }

    function safeLocalStorageGetItem(key) {
      try {
        return window.localStorage ? window.localStorage.getItem(key) : null;
      } catch (error) {
        appendDebug("Konnte localStorage nicht lesen.", describeError(error));
        return null;
      }
    }

    function safeLocalStorageSetItem(key, value) {
      try {
        if (window.localStorage) {
          window.localStorage.setItem(key, value);
        }
      } catch (error) {
        appendDebug("Konnte localStorage nicht schreiben.", describeError(error));
      }
    }

    function createClientId() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      const randomPart = Math.random().toString(16).slice(2, 10);
      return `client-${Date.now()}-${randomPart}`;
    }

    function getOrCreateClientId() {
      if (cachedClientId) {
        return cachedClientId;
      }
      const existing = safeLocalStorageGetItem(CLIENT_ID_STORAGE_KEY);
      if (existing && typeof existing === "string" && existing.trim()) {
        cachedClientId = existing.trim();
        return cachedClientId;
      }
      const newId = createClientId();
      cachedClientId = newId;
      safeLocalStorageSetItem(CLIENT_ID_STORAGE_KEY, newId);
      return cachedClientId;
    }

    function isoStringFromTimestamp(timestamp) {
      if (typeof timestamp !== "number" || Number.isNaN(timestamp)) {
        return null;
      }
      try {
        return new Date(timestamp).toISOString();
      } catch (_err) {
        return null;
      }
    }

    function truncateTextForDebug(text, maxLength = 90) {
      if (typeof text !== "string") {
        return "";
      }
      return text.length > maxLength ? `${text.slice(0, maxLength - 1)}‚Ä¶` : text;
    }

    function buildInstructionSpeech(ex) {
      if (!ex) return "";
      const name = (ex.name || "").trim();
      const instruction = (ex.instruction || "").trim();
      if (!instruction) return name;
      if (name && instruction.toLowerCase().startsWith(name.toLowerCase())) {
        const trimmedInstruction = instruction.slice(name.length).replace(/^[\s.:,-]+/, "").trim();
        return trimmedInstruction || instruction;
      }
      return name ? `${name}. ${instruction}` : instruction;
    }

    const initialVoiceMode = voiceModeRadios.find(radio => radio.checked)?.value;
    if (initialVoiceMode) {
      voiceMode = initialVoiceMode;
    }

    voiceModeRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        if (!radio.checked) return;
        voiceMode = radio.value;
        if (voiceMode !== "auto") {
          remoteFailureNotified = false;
          remoteBackoffActive = false;
          remoteFailureCount = 0;
          remoteRetryAvailableAt = 0;
          lastRemoteBackoffLogAt = 0;
          setStatus("");
        }
        appendDebug(
          voiceMode === "auto"
            ? "Sprachausgabe: Online-Modus mit Fallback aktiviert."
            : "Sprachausgabe: Lokaler Modus aktiviert."
        );
      });
    });

    if (repCountSlider) {
      repCountSlider.addEventListener("input", () => {
        const defaultCount = parseExerciseRepCount(exercise);
        if (!defaultCount) {
          return;
        }
        let value = Math.round(Number(repCountSlider.value));
        if (!Number.isInteger(value)) {
          value = defaultCount;
        }
        value = Math.max(1, Math.min(value, defaultCount));
        repCountSlider.value = String(value);
        selectedRepCount = value;
        if (!sessionRunning) {
          activeRepCount = null;
        }
        refreshRepSelectionLabel(value, defaultCount);
      });
    }

    if (setCountSlider) {
      setCountSlider.addEventListener("input", () => {
        const defaultCount = parseExerciseSetCount(exercise);
        if (!defaultCount) {
          return;
        }
        let value = Math.round(Number(setCountSlider.value));
        if (!Number.isInteger(value)) {
          value = defaultCount;
        }
        value = Math.max(1, Math.min(value, defaultCount));
        setCountSlider.value = String(value);
        selectedSetCount = value;
        if (!sessionRunning) {
          activeSetCount = null;
        }
        refreshSetSelectionLabel(value, defaultCount);
      });
    }

    if (breakBellToggle) {
      breakBellToggle.addEventListener("change", () => {
        refreshBreakBellStateLabel();
      });
      refreshBreakBellStateLabel();
    } else {
      refreshBreakBellStateLabel();
    }

    function base64ToBlob(base64, mimeType = "audio/mpeg") {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType });
    }

    function cancelActiveSpeech() {
      if (currentFetchController) {
        currentFetchController.abort();
        currentFetchController = null;
      }
      if (currentAudio) {
        currentAudio.pause();
      }
      if (hasBrowserSpeech) {
        speechSynthesis.cancel();
      }
      if (continueBtn) {
        continueBtn.disabled = true;
      }
    }

    async function callSpeechApi(text, { signal, voiceId, rate } = {}) {
      const payload = { text, language: "de-DE" };
      const requestedVoice =
        voiceId && typeof voiceId === "string" && voiceId.trim()
          ? voiceId.trim()
          : preferredVoice;
      if (requestedVoice) {
        payload.voice = requestedVoice;
      }
      if (typeof rate === "number" && Number.isFinite(rate) && rate > 0) {
        payload.rate = clampSpeechRate(rate);
      }

      const response = await fetch(SPEECH_API_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal,
      });

      const contentType = response.headers.get("content-type") || "";

      if (!response.ok) {
        let errorMessage = `Speech API Fehler (${response.status})`;
        if (contentType.includes("application/json")) {
          try {
            const data = await response.json();
            if (data && data.error) {
              errorMessage = data.error;
            }
          } catch (_err) {
            // ignore JSON parsing error
          }
        } else {
          const textMessage = await response.text();
          if (textMessage) {
            errorMessage = textMessage;
          }
        }
        throw new Error(errorMessage);
      }

      if (contentType.includes("application/json")) {
        const data = await response.json();
        if (data && data.audioUrl) {
          const audioResponse = await fetch(data.audioUrl, { signal });
          if (!audioResponse.ok) {
            throw new Error(`Konnte Audio-URL nicht laden (${audioResponse.status}).`);
          }
          return await audioResponse.blob();
        }
        if (data && data.audioBase64) {
          return base64ToBlob(data.audioBase64, data.mimeType || "audio/mpeg");
        }
        if (data && data.error) {
          throw new Error(data.error);
        }
        throw new Error("Unerwartete Antwort der Speech API.");
      }

      return await response.blob();
    }

    async function playRemoteAudio(text, { voiceId, rate } = {}) {
      const controller = new AbortController();
      currentFetchController = controller;

      let blob;
      try {
        blob = await callSpeechApi(text, { signal: controller.signal, voiceId, rate });
      } catch (error) {
        const abortedFetch =
          controller.signal.aborted ||
          skipRequested ||
          aborted ||
          (error && error.name === "AbortError");
        if (abortedFetch) {
          if (continueBtn) {
            continueBtn.disabled = true;
          }
          return;
        }
        throw error;
      } finally {
        if (currentFetchController === controller) {
          currentFetchController = null;
        }
      }

      if (aborted || skipRequested) {
        if (continueBtn) {
          continueBtn.disabled = true;
        }
        return;
      }

      const objectUrl = URL.createObjectURL(blob);
      currentAudioUrl = objectUrl;
      const audio = sharedAudioElement ?? new Audio();
      if (!sharedAudioElement) {
        audio.playsInline = true;
        audio.preload = "auto";
      } else {
        try {
          sharedAudioElement.pause();
        } catch (_err) {
          // ignore pause errors
        }
      }
      audio.muted = false;
      audio.src = objectUrl;
      try {
        audio.currentTime = 0;
      } catch (_err) {
        // ignore time reset errors
      }
      try {
        audio.load();
      } catch (_err) {
        // ignore load errors
      }
      currentAudio = audio;
      if (continueBtn) {
        continueBtn.disabled = false;
      }

      await new Promise((resolve, reject) => {
        let settled = false;

        function cleanup() {
          audio.removeEventListener("ended", onEnded);
          audio.removeEventListener("pause", onPause);
          audio.removeEventListener("error", onError);

          if (currentAudio === audio) {
            currentAudio = null;
          }
          if (currentAudioUrl === objectUrl) {
            URL.revokeObjectURL(objectUrl);
            currentAudioUrl = null;
          }
          if (continueBtn) {
            continueBtn.disabled = true;
          }
          try {
            audio.pause();
          } catch (_err) {
            // ignore pause errors
          }
          if (audio === sharedAudioElement) {
            try {
              audio.removeAttribute("src");
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          } else {
            try {
              audio.src = "";
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          }
        }

        function finish() {
          if (settled) return;
          settled = true;
          cleanup();
          resolve();
        }

        function fail(err) {
          if (settled) return;
          settled = true;
          cleanup();
          reject(err);
        }

        const onEnded = () => finish();
        const onPause = () => {
          if (!audio.ended) {
            finish();
          }
        };
        const onError = event => {
          const error = event instanceof Event && audio.error ? audio.error : null;
          fail(error || new Error("Audio playback failed"));
        };

        audio.addEventListener("ended", onEnded);
        audio.addEventListener("pause", onPause);
        audio.addEventListener("error", onError);

        audio.play().catch(err => {
          if (err && err.name === "NotAllowedError") {
            audioUnlocked = false;
            audioUnlockPromise = null;
            setStatus(
              "Browser blockiert die Audiowiedergabe. Tippe erneut, um sie zu aktivieren.",
              "warn"
            );
            appendDebug(
              "Audiowiedergabe durch den Browser blockiert.",
              describeError(err)
            );
          }
          fail(err);
        });
      });
    }

    function selectLocalVoice(voicePreference) {
      if (!hasBrowserSpeech || !voicePreference) {
        return null;
      }
      const normalized = voicePreference.trim().toLowerCase();
      if (!normalized) {
        return null;
      }
      try {
        const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
        if (!voices || !voices.length) {
          return null;
        }
        const exactMatch = voices.find(voice =>
          typeof voice.name === "string" && voice.name.trim().toLowerCase() === normalized
        );
        if (exactMatch) {
          return exactMatch;
        }
        const partialMatch = voices.find(voice =>
          typeof voice.name === "string" && voice.name.toLowerCase().includes(normalized)
        );
        if (partialMatch) {
          return partialMatch;
        }
      } catch (_err) {
        return null;
      }
      return null;
    }

    function clampSpeechRate(rate) {
      if (typeof rate !== "number" || !Number.isFinite(rate)) {
        return 1;
      }
      return Math.min(4, Math.max(0.1, rate));
    }

    function speakWithLocalSynthesis(text, options = {}) {
      return new Promise(resolve => {
        if (!hasBrowserSpeech) {
          setStatus("Sprachsynthese im Browser nicht verf√ºgbar.", "error");
          appendDebug("Lokale Sprachsynthese des Browsers nicht verf√ºgbar.");
          resolve();
          return;
        }

        continueBtn.disabled = false;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "de-DE";
        utterance.rate = clampSpeechRate(options.rate);
        if (options && typeof options.voiceId === "string") {
          const voice = selectLocalVoice(options.voiceId);
          if (voice) {
            utterance.voice = voice;
          }
        }

        let finished = false;
        const cancelWatcher = setInterval(() => {
          if (skipRequested || aborted) {
            speechSynthesis.cancel();
          }
        }, 100);

        let guardTimer = null;

        const cleanup = () => {
          clearInterval(cancelWatcher);
          if (guardTimer) {
            clearTimeout(guardTimer);
            guardTimer = null;
          }
          continueBtn.disabled = true;
        };

        const finish = () => {
          if (finished) return;
          finished = true;
          cleanup();
          resolve();
        };

        const scheduleGuard = () => {
          guardTimer = setTimeout(() => {
            if (speechSynthesis.speaking || speechSynthesis.pending) {
              scheduleGuard();
              return;
            }
            console.warn("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            appendDebug("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            finish();
          }, 4000);
        };

        utterance.onend = () => finish();

        utterance.onerror = () => finish();

        speechSynthesis.cancel();
        scheduleGuard();
        speechSynthesis.speak(utterance);
      });
    }

    function getAudioContextConstructor() {
      return typeof window !== "undefined"
        ? window.AudioContext || window.webkitAudioContext || null
        : null;
    }

    async function unlockAudioContext() {
      const AudioContextCtor = getAudioContextConstructor();
      if (!AudioContextCtor) {
        lastAudioUnlockError = "Keine Web-Audio-Unterst√ºtzung zur Tonfreigabe vorhanden.";
        return false;
      }

      if (audioContextUnlockPromise) {
        return audioContextUnlockPromise;
      }

      const attempt = (async () => {
        try {
          if (!sharedAudioContext) {
            sharedAudioContext = new AudioContextCtor();
          }
          const context = sharedAudioContext;
          if (!context) {
            return false;
          }
          if (context.state === "suspended") {
            await context.resume();
          }

          const frameCount = Math.max(Math.floor(context.sampleRate / 60), 1);
          const buffer = context.createBuffer(1, frameCount, context.sampleRate);
          const source = context.createBufferSource();
          source.buffer = buffer;
          source.connect(context.destination);
          try {
            source.start(0);
          } catch (_err) {
            // ignore start errors if source already stopped
          }
          return true;
        } catch (error) {
          appendDebug("Freischaltung via Web Audio fehlgeschlagen.", describeError(error));
          lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden (Web Audio).";
          return false;
        }
      })();

      audioContextUnlockPromise = attempt
        .then(success => {
          if (!success) {
            audioContextUnlockPromise = null;
          }
          return success;
        })
        .catch(error => {
          audioContextUnlockPromise = null;
          throw error;
        });

      return audioContextUnlockPromise;
    }

    function ensureAudioUnlocked() {
      if (audioUnlockPromise) return audioUnlockPromise;

      if (typeof Audio === "undefined") {
        audioUnlocked = true;
        lastAudioUnlockError = "";
        audioUnlockPromise = Promise.resolve(true);
        return audioUnlockPromise;
      }

      if (!sharedAudioElement) {
        sharedAudioElement = new Audio();
        sharedAudioElement.preload = "auto";
        sharedAudioElement.playsInline = true;
      }

      sharedAudioElement.muted = true;
      sharedAudioElement.src = SILENT_AUDIO_SRC;

      const unlockAttempt = sharedAudioElement
        .play()
        .then(() => true)
        .catch(async err => {
          console.warn("Konnte Audio nicht initialisieren.", err);
          const errorDescription = describeError(err);
          const isNotSupported = err && err.name === "NotSupportedError";
          const isNotAllowed = err && err.name === "NotAllowedError";

          if (isNotSupported) {
            appendDebug(
              "Stille Audiodatei zum Entsperren wird nicht unterst√ºtzt.",
              errorDescription
            );
            lastAudioUnlockError =
              "Browser unterst√ºtzt das Audioformat zur Freischaltung nicht.";
            const contextUnlocked = await unlockAudioContext();
            if (contextUnlocked) {
              lastAudioUnlockError = "";
              return true;
            }
          } else if (isNotAllowed) {
            appendDebug("Browser blockiert die Audiowiedergabe.", errorDescription);
            lastAudioUnlockError =
              "Browser blockiert die Audiowiedergabe. Bitte tippe erneut, um Ton zu aktivieren.";
          } else {
            appendDebug("Audio konnte nicht freigeschaltet werden.", errorDescription);
            lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden.";
          }
          return false;
        })
        .finally(() => {
          try {
            sharedAudioElement.pause();
            sharedAudioElement.currentTime = 0;
            sharedAudioElement.removeAttribute("src");
            sharedAudioElement.load();
          } catch (_err) {
            // ignore cleanup errors
          }
          sharedAudioElement.muted = false;
        });

      audioUnlockPromise = unlockAttempt.then(success => {
        audioUnlocked = success;
        if (!success) {
          audioUnlockPromise = null;
        }
        return success;
      });

      return audioUnlockPromise;
    }

    const userActivationEvents = ["pointerdown", "touchstart", "keydown"];
    userActivationEvents.forEach(eventName => {
      window.addEventListener(
        eventName,
        () => {
          if (!audioUnlocked) {
            ensureAudioUnlocked();
          }
        },
        { once: true, capture: true }
      );
    });

    async function speak(text, options = {}) {
      if (aborted) return;

      skipRequested = false;

      const attemptStart = now();
      const truncatedText = truncateTextForDebug(text);
      const preferRemote = voiceMode === "auto";
      const canUseRemote = preferRemote && (!remoteBackoffActive || now() >= remoteRetryAvailableAt);
      const voiceOverride =
        options && typeof options.voiceId === "string" ? options.voiceId.trim() : "";
      const desiredRate = options && typeof options.rate === "number" ? options.rate : undefined;

      if (preferRemote && canUseRemote) {
        try {
          await playRemoteAudio(text, { voiceId: voiceOverride, rate: desiredRate });
          const duration = Math.round(now() - attemptStart);
          if (duration > REMOTE_SPEECH_SLOW_THRESHOLD_MS && truncatedText) {
            appendDebug(
              `Online-Sprachsynthese ben√∂tigte ${duration} ms f√ºr eine Antwort.`,
              `Text: "${truncatedText}"`
            );
          }
          if (remoteFailureNotified) {
            if (truncatedText) {
              appendDebug(
                "Online-Sprachsynthese wieder verf√ºgbar.",
                `Text: "${truncatedText}"`
              );
            } else {
              appendDebug("Online-Sprachsynthese wieder verf√ºgbar.");
            }
            setStatus("");
            remoteFailureNotified = false;
          }
          remoteFailureCount = 0;
          remoteBackoffActive = false;
          remoteRetryAvailableAt = 0;
          lastRemoteBackoffLogAt = 0;
          return;
        } catch (error) {
          if (aborted || skipRequested || (error && error.name === "AbortError")) {
            return;
          }
          const duration = Math.round(now() - attemptStart);
          console.warn("Speech API nicht erreichbar, nutze Fallback.", error);
          const details = [
            `Grund: ${describeError(error)}`,
            truncatedText ? `Text: "${truncatedText}"` : "",
          ]
            .filter(Boolean)
            .join("\n");
          appendDebug(
            `Online-Sprachsynthese fehlgeschlagen nach ${duration} ms.`,
            details
          );
          if (preferRemote && !remoteFailureNotified) {
            setStatus(
              "Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.",
              "warn"
            );
            remoteFailureNotified = true;
          }
          remoteFailureCount = Math.min(remoteFailureCount + 1, 6);
          const backoffExponent = Math.max(remoteFailureCount - 1, 0);
          const backoffDelay = Math.min(
            REMOTE_RETRY_BASE_DELAY_MS * Math.pow(2, backoffExponent),
            REMOTE_RETRY_MAX_DELAY_MS
          );
          remoteRetryAvailableAt = now() + backoffDelay;
          remoteBackoffActive = true;
          lastRemoteBackoffLogAt = 0;
          const backoffSeconds = Math.max(1, Math.round(backoffDelay / 1000));
          appendDebug(`Online-Sprachsynthese pausiert f√ºr ${backoffSeconds} s.`);
          skipRequested = false;
          if (truncatedText) {
            appendDebug(
              "Wechsle auf lokale Sprachsynthese.",
              `Text: "${truncatedText}"`
            );
          } else {
            appendDebug("Wechsle auf lokale Sprachsynthese.");
          }
          await speakWithLocalSynthesis(text, { voiceId: voiceOverride, rate: desiredRate });
          return;
        }
      }

      if (preferRemote) {
        if (!remoteFailureNotified) {
          setStatus(
            "Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.",
            "warn"
          );
          remoteFailureNotified = true;
        }

        if (remoteBackoffActive) {
          const remainingMs = Math.max(remoteRetryAvailableAt - now(), 0);
          if (
            !lastRemoteBackoffLogAt ||
            now() - lastRemoteBackoffLogAt >= REMOTE_BACKOFF_LOG_THROTTLE_MS
          ) {
            const secondsRemaining = Math.max(1, Math.ceil(remainingMs / 1000));
            const logMessage = `√úberspringe Online-Sprachsynthese (noch ${secondsRemaining} s Auszeit).`;
            const details = truncatedText ? `Text: "${truncatedText}"` : "";
            appendDebug(logMessage, details);
            lastRemoteBackoffLogAt = now();
          }
        }
      } else {
        if (remoteFailureNotified) {
          setStatus("");
          remoteFailureNotified = false;
        }
        remoteBackoffActive = false;
        remoteRetryAvailableAt = 0;
        lastRemoteBackoffLogAt = 0;
      }

      skipRequested = false;
      await speakWithLocalSynthesis(text, { voiceId: voiceOverride, rate: desiredRate });
      return;
    }

    // --- Inhalte laden ---
    fetch("mindfulness.json")
      .then(res => {
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        const prompts = flattenMindfulnessPrompts(data);
        mindfulnessPrompts = prompts;
        if (prompts.length > 0) {
          appendDebug(`Mindfulness-Impulse geladen (${prompts.length}).`);
        } else {
          appendDebug("Keine Mindfulness-Impulse gefunden.");
        }
      })
      .catch(error => {
        mindfulnessPrompts = [];
        console.error("Fehler beim Laden der Mindfulness-Impulse", error);
        appendDebug("Mindfulness-Impulse konnten nicht geladen werden.", describeError(error));
      });

    // --- √úbungen laden ---
    const exercisesApiUrl = (window.STRETCH_COACH_CONFIG || {}).exercisesApiUrl;

    const normalizeExercises = data => {
      if (!data) {
        return [];
      }
      if (Array.isArray(data)) {
        return data;
      }
      if (Array.isArray(data.items)) {
        return data.items;
      }
      return [];
    };

    const loadExercisesFromUrl = url =>
      fetch(url, {
        cache: "no-store",
        headers: { Accept: "application/json" },
      })
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(normalizeExercises);

    const populateExercises = list => {
      exercises = list.filter(entry => entry && typeof entry.id === "string");
      select.innerHTML = exercises.map(e => `<option value="${e.id}">${e.name}</option>`).join("");
      exercise = exercises[0] ?? null;
      applyBreakBellPreset(exercise);
      updateExerciseOverview(exercise, { resetRepSelection: true, resetSetSelection: true });
      resetSessionUI();
      if (openSessionBtn) {
        openSessionBtn.disabled = exercises.length === 0;
      }
    };

    const fallbackToStaticFile = error => {
      if (error) {
        console.warn("Prim√§rer Abruf der √úbungen fehlgeschlagen, versuche Fallback", error);
      }
      return loadExercisesFromUrl("exercises.json");
    };

    const exercisePromise = exercisesApiUrl
      ? loadExercisesFromUrl(exercisesApiUrl).catch(fallbackToStaticFile)
      : fallbackToStaticFile();

    exercisePromise
      .then(populateExercises)
      .catch(err => {
        console.error("Fehler beim Laden der √úbungen", err);
        select.innerHTML = "<option>Fehler beim Laden</option>";
        setStatus("√úbungen konnten nicht geladen werden.", "error");
      });

    countdownStepSelect.innerHTML = Array.from(
      { length: Math.floor((COUNTDOWN_MAX_MS - COUNTDOWN_MIN_MS) / COUNTDOWN_STEP_INCREMENT_MS) + 1 },
      (_, idx) => {
        const value = COUNTDOWN_MIN_MS + idx * COUNTDOWN_STEP_INCREMENT_MS;
        const selected = value === countdownStepMs ? " selected" : "";
        return `<option value="${value}"${selected}>${value} ms</option>`;
      }
    ).join("");

    // --- Countdown ---
    async function countdown(seconds, label = "", finalCue = "") {
      let remaining = seconds;
      const buildLabel = value => `${label}${label ? " " : ""}${value}`;
      while (remaining > 0) {
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
          continue;
        }
        const text = buildLabel(remaining);
        display.textContent = text;
        await speak(remaining.toString());
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
          continue;
        }
        await new Promise(r => setTimeout(r, countdownStepMs));
        if (aborted) return;
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
        }
        remaining -= 1;
      }
      if (finalCue && !aborted) {
        if (pauseRequested) {
          await handleCountdownPause();
          if (aborted) return;
        }
        display.textContent = finalCue;
        await speak(finalCue);
      }
    }

    async function runRepTimer(seconds) {
      const totalDurationMs = Math.max(0, seconds * 1000);
      if (totalDurationMs <= 0) {
        return;
      }
      if (!repProgressContainer || !repProgressBar) {
        await new Promise(r => setTimeout(r, totalDurationMs));
        return;
      }

      repProgressContainer.hidden = false;
      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      void repProgressBar.offsetWidth; // Force reflow to restart transition
      repProgressBar.style.transition = "width 0.25s ease";

      const steps = Math.max(1, Math.round(seconds));
      const finalStepDuration = Math.max(totalDurationMs - (steps - 1) * 1000, 0);

      for (let step = 1; step <= steps; step++) {
        if (aborted) break;
        const waitMs = step === steps ? finalStepDuration || 1000 : 1000;
        if (waitMs > 0) {
          await new Promise(r => setTimeout(r, waitMs));
        }
        if (aborted) break;
        const progress = Math.min((step / steps) * 100, 100);
        repProgressBar.style.width = `${progress}%`;
      }

      if (!aborted) {
        await new Promise(r => setTimeout(r, 150));
      }

      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      repProgressContainer.hidden = true;
    }

    // --- Satz ---
    async function runSet(setNr, withPrep) {
      if (aborted) return;
      if (withPrep) {
        display.textContent = `Vorbereitung (Satz ${setNr})...`;
        await speak(`${exercise.prep_time} Sekunden Countdown`);
        await countdown(exercise.prep_time, "", "Los!");
      } else {
        await speak("Weiter mit dem n√§chsten Satz. Los!");
      }

      const repsPerSet = Math.max(0, getSessionRepCount());
      for (let i = 1; i <= repsPerSet && !aborted; i++) {
        display.textContent = `Wiederholung ${i}`;
        await runRepTimer(exercise.rep_time);
        if (aborted) break;
        await speak(i.toString());
        if (aborted) break;
        await handlePauseIfNeeded();
      }

      if (!aborted) {
        display.textContent = `Satz ${setNr} beendet!`;
        await speak(`Satz ${setNr} beendet.`);
      }
    }

    async function recordExerciseCompletion({
      exercise: exerciseToStore,
      totalSets,
      completedSets,
      startedAt,
      finishedAt,
      durationMs,
    }) {
      if (!exerciseToStore || !exerciseToStore.id) {
        return;
      }
      if (!PROGRESS_API_ENDPOINT) {
        appendDebug("Fortschritts-API ist nicht konfiguriert.");
        return;
      }

      const clientId = getOrCreateClientId();
      if (!clientId) {
        appendDebug("Kein Client-Identifier verf√ºgbar ‚Äì Fortschritt wird nicht gespeichert.");
        return;
      }

      const resolvedTotalSets = Number.isInteger(totalSets)
        ? totalSets
        : Number.isInteger(exerciseToStore.sets)
        ? exerciseToStore.sets
        : 0;
      const resolvedCompletedSets = Number.isInteger(completedSets)
        ? completedSets
        : resolvedTotalSets;

      if (resolvedTotalSets <= 0 || resolvedCompletedSets < resolvedTotalSets) {
        appendDebug("√úbung nicht vollst√§ndig abgeschlossen ‚Äì kein Speichern.");
        return;
      }

      const payload = {
        clientId,
        exerciseId: String(exerciseToStore.id),
        totalSets: resolvedTotalSets,
        setsCompleted: resolvedCompletedSets,
      };

      if (exerciseToStore.name) {
        payload.exerciseName = String(exerciseToStore.name);
      }
      if (Number.isInteger(exerciseToStore.rep_time) && exerciseToStore.rep_time > 0) {
        payload.repTime = Math.trunc(exerciseToStore.rep_time);
      }
      if (Number.isInteger(exerciseToStore.rest_time) && exerciseToStore.rest_time >= 0) {
        payload.restTime = Math.trunc(exerciseToStore.rest_time);
      }
      if (Number.isInteger(exerciseToStore.prep_time) && exerciseToStore.prep_time >= 0) {
        payload.prepTime = Math.trunc(exerciseToStore.prep_time);
      }
      if (Number.isInteger(durationMs) && durationMs >= 0) {
        payload.durationMs = durationMs;
      }

      const startedIso = isoStringFromTimestamp(startedAt);
      if (startedIso) {
        payload.startedAt = startedIso;
      }
      const finishedIso = isoStringFromTimestamp(finishedAt);
      if (finishedIso) {
        payload.finishedAt = finishedIso;
      }

      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), COMPLETION_REQUEST_TIMEOUT_MS);
      appendDebug(
        `Speichere √úbungsabschluss f√ºr '${payload.exerciseName || payload.exerciseId}'.`,
        `S√§tze: ${resolvedCompletedSets}/${resolvedTotalSets}`
      );

      try {
        const response = await fetch(PROGRESS_API_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        if (!response.ok) {
          const contentType = response.headers.get("content-type") || "";
          let errorDetail = `${response.status}`;
          if (contentType.includes("application/json")) {
            try {
              const data = await response.json();
              if (data && data.error) {
                errorDetail = `${response.status} ${data.error}`;
              }
            } catch (_err) {
              // ignore JSON parse error
            }
          } else {
            const text = await response.text();
            if (text) {
              errorDetail = `${response.status} ${text}`;
            }
          }
          appendDebug("Fortschritt konnte nicht gespeichert werden.", errorDetail);
          return;
        }

        appendDebug("Fortschritt erfolgreich gespeichert.");
        refreshStreakIndicator().catch(() => {});
      } catch (error) {
        if (controller.signal.aborted) {
          appendDebug("Fortschrittsspeicherung abgebrochen (Timeout).");
        } else {
          appendDebug("Fehler beim Speichern des Fortschritts.", describeError(error));
        }
      } finally {
        window.clearTimeout(timeoutId);
      }
    }

    // --- Training ---
    async function doExercise() {
      aborted = false;
      skipRequested = false;
      pauseRequested = false;
      pauseAwaitingResume = false;
      pauseResumeResolver = null;

      if (!remoteFailureNotified) {
        setStatus("");
      }

      resetProgress();

      const instructionSpeech = buildInstructionSpeech(exercise);
      if (instructionSpeech) {
        display.textContent = instructionSpeech;
      } else if (exercise && exercise.name) {
        display.textContent = exercise.name;
      }
      await speak(`Pro √úbungsdurchf√ºhrung sind ${exercise.rep_time} Sekunden geplant.`);
      if (instructionSpeech) {
        await speak(instructionSpeech);
      }

      const exerciseStartAt = Date.now();
      const plannedSetCount = Math.max(1, getSessionSetCount());
      let completedSets = 0;

      for (let set = 1; set <= plannedSetCount && !aborted; set++) {
        const withPrep = set === 1;
        await runSet(set, withPrep);
        if (aborted) break;

        completedSets += 1;

        if (set < plannedSetCount) {
          const wantsMindfulness =
            typeof exercise.mindfulness === "string" &&
            exercise.mindfulness.trim().toLowerCase() === "yes";
          if (isBreakBellEnabled() && !wantsMindfulness) {
            await playBreakBellCue();
          }
          await speak(`Pause ${exercise.rest_time} Sekunden.`);
          const restSecondsNumeric = Number(exercise.rest_time);
          const restSeconds = Number.isFinite(restSecondsNumeric) ? restSecondsNumeric : 0;
          const basePauseText = `Pause: ${exercise.rest_time}s`;
          const restWaitMs = Math.max(0, (restSeconds - 5) * 1000);
          const restorePauseDisplay = () => {
            if (display && !aborted) {
              display.textContent = basePauseText;
            }
          };

          display.textContent = basePauseText;

          if (restWaitMs > 0) {
            if (wantsMindfulness) {
              const beforePromptMs = Math.floor(restWaitMs / 2);
              const afterPromptMs = Math.max(restWaitMs - beforePromptMs, 0);
              const shouldPlayBreakBellDuringPause = isBreakBellEnabled();

              if (shouldPlayBreakBellDuringPause) {
                const waitBeforeChime = Math.max(
                  0,
                  Math.min(beforePromptMs, restWaitMs) - BREAK_BELL_PROMPT_LEAD_MS
                );
                if (waitBeforeChime > 0) {
                  await waitWithPauseSupport(waitBeforeChime, { onResume: restorePauseDisplay });
                  if (aborted) break;
                }

                if (!aborted) {
                  await playBreakBellCue();
                  if (aborted) break;
                }

                const waitAfterChimeBeforePrompt = Math.min(
                  BREAK_BELL_PROMPT_LEAD_MS,
                  Math.max(beforePromptMs - waitBeforeChime, 0),
                  Math.max(restWaitMs - waitBeforeChime, 0)
                );
                if (waitAfterChimeBeforePrompt > 0 && !aborted) {
                  await waitWithPauseSupport(waitAfterChimeBeforePrompt, { onResume: restorePauseDisplay });
                  if (aborted) break;
                }
              } else if (beforePromptMs > 0) {
                await waitWithPauseSupport(beforePromptMs, { onResume: restorePauseDisplay });
                if (aborted) break;
              }

              const prompt = getRandomMindfulnessPrompt();
              if (prompt && !aborted) {
                const promptDisplayText = `${basePauseText} ‚Äì ${prompt}`;
                if (pauseRequested && !aborted) {
                  await handlePauseIfNeeded();
                  if (aborted) break;
                  restorePauseDisplay();
                }
                if (!aborted) {
                  display.textContent = promptDisplayText;
                  try {
                    await speak(prompt, { voiceId: "Daniel", rate: MINDFULNESS_SPEECH_RATE });
                  } finally {
                    if (!aborted) {
                      restorePauseDisplay();
                    }
                  }
                  if (aborted) break;
                }
              }

              if (afterPromptMs > 0 && !aborted) {
                await waitWithPauseSupport(afterPromptMs, { onResume: restorePauseDisplay });
              }
            } else {
              await waitWithPauseSupport(restWaitMs, { onResume: restorePauseDisplay });
            }
          }
          if (aborted) break;
          await speak("Noch f√ºnf Sekunden");
          await countdown(5, "", ""); // kein Los! hier
        }
      }

      const exerciseFinishedAt = Date.now();

      if (!aborted) {
        display.textContent = "Fertig! Gut gemacht üéâ";
        await speak("Fertig! Gut gemacht.");
        await recordExerciseCompletion({
          exercise,
          totalSets: plannedSetCount,
          completedSets,
          startedAt: exerciseStartAt,
          finishedAt: exerciseFinishedAt,
          durationMs: Math.max(0, exerciseFinishedAt - exerciseStartAt),
        });
      } else {
        display.textContent = "Abgebrochen.";
        await speak("Training abgebrochen.");
      }
    }

    // --- Events ---
    select.addEventListener("change", () => {
      const id = select.value;
      exercise = exercises.find(e => e.id === id) ?? null;
      applyBreakBellPreset(exercise);
      updateExerciseOverview(exercise, { resetRepSelection: true, resetSetSelection: true });
      if (openSessionBtn) {
        openSessionBtn.disabled = !exercise;
      }
      const modalVisible = exerciseModal && !exerciseModal.hidden;
      if (!sessionRunning && modalVisible) {
        resetSessionUI();
      } else if (!sessionRunning && display) {
        const preview = buildInstructionSpeech(exercise);
        display.textContent = preview || (exercise && exercise.name ? exercise.name : "Bereit?");
      }
    });

    if (mindfulnessPromptBtn) {
      mindfulnessPromptBtn.addEventListener("click", async () => {
        if (mindfulnessPromptActive) {
          return;
        }

        if (sessionRunning) {
          setStatus(
            "W√§hrend eines laufenden Trainings steht der Achtsamkeitsspruch nicht zur Verf√ºgung.",
            "warn"
          );
          appendDebug(
            "Achtsamkeitsspruch (Startseite) √ºbersprungen, Session l√§uft bereits."
          );
          return;
        }

        const prompt = getRandomMindfulnessPrompt();
        if (!prompt) {
          setStatus("Es sind keine Achtsamkeitsspr√ºche verf√ºgbar.", "warn");
          appendDebug("Achtsamkeitsspruch (Startseite) nicht verf√ºgbar ‚Äì keine Texte geladen.");
          return;
        }

        mindfulnessPromptActive = true;
        mindfulnessPromptBtn.disabled = true;

        try {
          await playStandaloneMindfulnessPrompt(prompt);
        } finally {
          mindfulnessPromptActive = false;
          mindfulnessPromptBtn.disabled = false;
        }
      });
    }

    if (exerciseDetailsBtn) {
      exerciseDetailsBtn.addEventListener("click", () => {
        exercise = exercises.find(e => e.id === select.value) ?? exercise;
        if (!exercise) {
          return;
        }
        updateExerciseOverview(exercise);
        if (exerciseDetailsModal) {
          openModal(exerciseDetailsModal);
        }
      });
    }

    if (closeExerciseDetailsBtn) {
      closeExerciseDetailsBtn.addEventListener("click", () => {
        if (exerciseDetailsModal) {
          closeModal(exerciseDetailsModal);
        }
      });
    }

    if (exerciseDetailsModal) {
      closeModal(exerciseDetailsModal);
      exerciseDetailsModal.addEventListener("click", event => {
        if (event.target === exerciseDetailsModal) {
          closeModal(exerciseDetailsModal);
        }
      });
    }

    if (openSessionBtn) {
      openSessionBtn.addEventListener("click", () => {
        exercise = exercises.find(e => e.id === select.value) ?? null;
        if (!exercise) {
          setStatus("Bitte zuerst eine √úbung ausw√§hlen.", "warn");
          return;
        }
        updateExerciseOverview(exercise);
        resetSessionUI();
        openModal(exerciseModal);
      });
    }

    if (sessionCloseBtn) {
      sessionCloseBtn.addEventListener("click", () => {
        if (sessionRunning) {
          return;
        }
        closeModal(exerciseModal);
      });
    }

    if (startBtn) {
      startBtn.addEventListener("click", async () => {
        if (sessionRunning) return;
        exercise = exercises.find(e => e.id === select.value) ?? null;
        if (!exercise) return;
        const unlocked = await ensureAudioUnlocked();
        if (!unlocked) {
          const warningMessage =
            lastAudioUnlockError ||
            "Audioausgabe wurde vom Browser blockiert. Bitte tippe erneut oder pr√ºfe die Autoplay-Einstellungen.";
          setStatus(warningMessage, "warn");
          appendDebug(
            "Audio konnte nicht freigeschaltet werden.",
            lastAudioUnlockError ? truncateTextForDebug(lastAudioUnlockError, 200) : ""
          );
          return;
        }
        lastAudioUnlockError = "";
        startSessionUI();
        try {
          await doExercise();
          finishSessionUI({ completed: !aborted });
        } catch (error) {
          console.error("Fehler w√§hrend der √úbung", error);
          appendDebug("Fehler w√§hrend der √úbung.", describeError(error));
          finishSessionUI({ completed: false });
        }
      });
    }

    if (continueBtn) {
      continueBtn.addEventListener("click", async () => {
        if (continueBtn.disabled) return;
        if (pauseAwaitingResume) {
          await resumeFromPause();
          return;
        }
        skipRequested = true;
        if (currentFetchController) {
          currentFetchController.abort();
        }
        if (currentAudio) {
          currentAudio.pause();
        } else if (hasBrowserSpeech) {
          speechSynthesis.cancel();
        }
        continueBtn.disabled = true;
      });
    }

    if (pauseBtn) {
      pauseBtn.addEventListener("click", () => {
        if (!sessionRunning || pauseRequested || pauseAwaitingResume) {
          return;
        }
        pauseRequested = true;
        pauseBtn.disabled = true;
        appendDebug("Pause wird nach der aktuellen Wiederholung aktiviert.");
      });
    }
    countdownStepSelect.addEventListener("change", () => {
      countdownStepMs = Number(countdownStepSelect.value);
    });
    if (stopBtn) {
      stopBtn.addEventListener("click", () => {
        if (!sessionRunning) {
          return;
        }
        const shouldAbort = window.confirm("M√∂chtest du die √úbung wirklich abbrechen?");
        if (!shouldAbort) {
          return;
        }
        aborted = true;
        pauseRequested = false;
        skipRequested = false;
        resolvePauseAwaiting();
        cancelActiveSpeech();
        if (display) {
          display.textContent = "Abbruch...";
        }
        if (continueBtn) {
          continueBtn.disabled = true;
        }
        if (pauseBtn) {
          pauseBtn.disabled = true;
        }
        stopBtn.disabled = true;
        remoteFailureNotified = false;
        setStatus("Training gestoppt.", "info");
        appendDebug("Training wurde abgebrochen.");
        resetProgress();
      });
    }

    if (debugLogBtn) {
      debugLogBtn.addEventListener("click", () => {
        refreshDebugLog();
        openModal(debugModal);
      });
    }

    if (closeDebugModalBtn) {
      closeDebugModalBtn.addEventListener("click", () => {
        closeModal(debugModal);
      });
    }

    if (debugModal) {
      closeModal(debugModal);
      debugModal.addEventListener("click", event => {
        if (event.target === debugModal) {
          closeModal(debugModal);
        }
      });
    }

    if (beatsRadioBtn) {
      beatsRadioBtn.addEventListener("click", () => {
        const beatsWindow = window.open(
          "https://www.beatsradio.de/",
          "_blank",
          "noopener,noreferrer"
        );
        if (beatsWindow) {
          beatsWindow.focus();
        }
      });
    }

    if (viewStatsBtn) {
      viewStatsBtn.addEventListener("click", () => {
        window.location.href = "./exercise-completions.html";
      });
    }

    refreshStreakIndicator().catch(() => {});

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./service-worker.js")
          .catch(err => console.error("Service Worker registration failed", err));
      });
    }
  </script>
</body>
</html>
