<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#3d8bff" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <title>Stretch Coach</title>
  <style>
    :root {
      color-scheme: light;
      --bg-gradient: linear-gradient(135deg, #7f7fd5, #86a8e7, #91eae4);
      --surface: rgba(255, 255, 255, 0.9);
      --text-primary: #1a2a3a;
      --text-secondary: #516170;
      --accent: #3d8bff;
      --accent-strong: #2f6ad8;
      --accent-warn: #f39c12;
      --accent-stop: #e74c3c;
      --radius-large: 24px;
      --shadow: 0 20px 40px rgba(26, 42, 58, 0.18);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont,
        "Helvetica Neue", Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4vw 5vw;
      background: var(--bg-gradient);
      color: var(--text-primary);
    }

    .app-card {
      width: min(440px, 100%);
      padding: clamp(1.8rem, 4vw, 2.6rem);
      background: var(--surface);
      backdrop-filter: blur(10px);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow);
      display: grid;
      gap: clamp(1rem, 2.5vw, 1.6rem);
    }

    header {
      text-align: center;
      display: grid;
      gap: 0.4rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 4vw, 2.4rem);
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.4rem;
    }

    .input-group {
      display: grid;
      gap: 0.45rem;
    }

    select {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      border-radius: 16px;
      border: 1px solid rgba(61, 139, 255, 0.2);
      background: rgba(255, 255, 255, 0.85);
      color: var(--text-primary);
      appearance: none;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus {
      border-color: rgba(61, 139, 255, 0.6);
      box-shadow: 0 0 0 4px rgba(61, 139, 255, 0.2);
    }

    #display {
      min-height: 3.2rem;
      display: grid;
      place-items: center;
      padding: 1.2rem;
      font-size: clamp(1.6rem, 4.5vw, 2.4rem);
      font-weight: 600;
      border-radius: 20px;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-primary);
      line-height: 1.3;
    }

    .actions {
      display: grid;
      gap: 0.75rem;
    }

    @media (min-width: 480px) {
      .actions {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    #statusMessage {
      min-height: 0;
      padding: 0.75rem 1rem;
      border-radius: 14px;
      font-size: 0.9rem;
      line-height: 1.4;
      background: rgba(61, 139, 255, 0.08);
      color: var(--text-secondary);
      box-shadow: inset 0 0 0 1px rgba(61, 139, 255, 0.15);
    }

    #statusMessage[data-type="warn"] {
      background: rgba(243, 156, 18, 0.15);
      color: #8c5a05;
      box-shadow: inset 0 0 0 1px rgba(243, 156, 18, 0.3);
    }

    #statusMessage[data-type="error"] {
      background: rgba(231, 76, 60, 0.18);
      color: #a12315;
      box-shadow: inset 0 0 0 1px rgba(231, 76, 60, 0.35);
    }

    .debug-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .debug-toggle input {
      accent-color: var(--accent);
      width: 1.1rem;
      height: 1.1rem;
    }

    #debugPanel {
      padding: 0.85rem 1rem;
      border-radius: 14px;
      background: rgba(26, 42, 58, 0.08);
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.5;
      display: grid;
      gap: 0.4rem;
      box-shadow: inset 0 0 0 1px rgba(26, 42, 58, 0.12);
    }

    #debugPanel strong {
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    #debugLog {
      font-family: "SFMono-Regular", "Roboto Mono", Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
      padding: 0.75rem;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.65);
      box-shadow: inset 0 0 0 1px rgba(61, 139, 255, 0.12);
      max-height: 180px;
      overflow-y: auto;
    }

    button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.85rem 1rem;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      color: #fff;
      background: var(--accent);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s ease;
      box-shadow: 0 10px 20px rgba(61, 139, 255, 0.25);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.03);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      filter: brightness(0.98);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    #skipBtn {
      background: var(--accent-warn);
      box-shadow: 0 10px 20px rgba(243, 156, 18, 0.2);
    }

    #stopBtn {
      background: var(--accent-stop);
      box-shadow: 0 10px 20px rgba(231, 76, 60, 0.25);
    }

    .progress-container {
      width: 100%;
      height: 10px;
      background: rgba(61, 139, 255, 0.12);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-strong));
      transition: width 0.25s ease;
    }

    footer {
      text-align: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    footer span {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
  </style>
</head>
<body>
  <div class="app-card">
    <header>
      <h1>üßò Stretch Coach</h1>
      <p>Starte dein gef√ºhrtes Stretching ‚Äì mit Sprachansagen und pr√§zisem Timing.</p>
    </header>

    <div class="input-group">
      <label for="exerciseSelect">√úbung w√§hlen</label>
      <select id="exerciseSelect"><option>Lade √úbungen...</option></select>
    </div>

    <div class="input-group">
      <label for="countdownStepSelect">Countdown-Takt</label>
      <select id="countdownStepSelect"></select>
    </div>

    <div id="display">Bereit?</div>
    <div class="progress-container" id="repProgressContainer" hidden>
      <div class="progress-bar" id="repProgressBar" aria-hidden="true"></div>
    </div>

    <div class="actions">
      <button id="startBtn" disabled>Start</button>
      <button id="skipBtn" disabled>Weiter</button>
      <button id="stopBtn" disabled>Abbrechen</button>
    </div>

    <div id="statusMessage" role="status" aria-live="polite" hidden></div>
    <label class="debug-toggle">
      <input type="checkbox" id="debugToggle" />
      Debug-Ausgabe anzeigen
    </label>
    <div id="debugPanel" hidden aria-live="polite" aria-label="Debugmeldungen">
      <strong>Debug-Ausgaben</strong>
      <pre id="debugLog"></pre>
    </div>

    <footer>
      <span>Bleib flexibel und achtsam ‚ú®</span>
    </footer>
  </div>

  <script src="./config.production.js"></script>
  <script>
    const countdownStepSelect = document.getElementById("countdownStepSelect");

    const COUNTDOWN_MIN_MS = 100;
    const COUNTDOWN_MAX_MS = 1000;
    const COUNTDOWN_STEP_INCREMENT_MS = 100;
    let countdownStepMs = 200;
    let exercises = [];
    let exercise = null;
    let skipRequested = false;
    let aborted = false;
    const hasBrowserSpeech = "speechSynthesis" in window;
    let currentAudio = null;
    let currentAudioUrl = null;
    let currentFetchController = null;
    let remoteFailureNotified = false;
    let remoteBackoffActive = false;
    let remoteRetryAvailableAt = 0;
    let remoteFailureCount = 0;
    let lastRemoteBackoffLogAt = 0;
    let audioUnlockPromise = null;
    let sharedAudioElement = null;
    let sharedAudioContext = null;
    let audioContextUnlockPromise = null;
    let audioUnlocked = false;
    let lastAudioUnlockError = "";

    const display = document.getElementById("display");
    const startBtn = document.getElementById("startBtn");
    const skipBtn = document.getElementById("skipBtn");
    const stopBtn = document.getElementById("stopBtn");
    const select = document.getElementById("exerciseSelect");
    const statusMessage = document.getElementById("statusMessage");
    const debugPanel = document.getElementById("debugPanel");
    const debugLog = document.getElementById("debugLog");
    const debugToggle = document.getElementById("debugToggle");
    const debugEntries = [];
    const repProgressContainer = document.getElementById("repProgressContainer");
    const repProgressBar = document.getElementById("repProgressBar");
    const DEBUG_MAX_ENTRIES = 12;
    const REMOTE_SPEECH_SLOW_THRESHOLD_MS = 1500;
    const REMOTE_RETRY_BASE_DELAY_MS = 4000;
    const REMOTE_RETRY_MAX_DELAY_MS = 60000;
    const REMOTE_BACKOFF_LOG_THROTTLE_MS = 3000;
    const SILENT_AUDIO_SRC =
      "data:audio/wav;base64,UklGRrQBAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YZABAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA";
    const now = () => (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now());

    const speechConfig = window.STRETCH_COACH_CONFIG || {};
    const preferredVoice = speechConfig.voiceId ? String(speechConfig.voiceId) : null;
    const SPEECH_API_ENDPOINT = determineSpeechEndpoint(speechConfig);

    function stripTrailingSlash(value) {
      return value.replace(/\/+$/, "");
    }

    function determineSpeechEndpoint(config) {
      if (config && config.speechApiUrl) {
        const normalized = stripTrailingSlash(String(config.speechApiUrl));
        return normalized || "/api/speak";
      }
      if (config && config.speechApiBaseUrl) {
        const normalizedBase = stripTrailingSlash(String(config.speechApiBaseUrl));
        return normalizedBase ? `${normalizedBase}/api/speak` : "/api/speak";
      }
      return "/api/speak";
    }

    function setStatus(message = "", type = "info") {
      if (!statusMessage) return;
      if (!message) {
        statusMessage.textContent = "";
        statusMessage.hidden = true;
        statusMessage.removeAttribute("data-type");
        return;
      }
      statusMessage.hidden = false;
      statusMessage.textContent = message;
      statusMessage.setAttribute("data-type", type);
    }

    function appendDebug(message, details = "") {
      if (!debugPanel || !debugLog) return;
      const timestamp = new Date().toLocaleTimeString();
      let entry = `[${timestamp}] ${message}`;
      if (details) {
        entry += `\n${details}`;
      }
      debugEntries.push(entry);
      while (debugEntries.length > DEBUG_MAX_ENTRIES) {
        debugEntries.shift();
      }
      updateDebugVisibility();
    }

    function describeError(error) {
      if (!error) return "Unbekannter Fehler";
      if (error instanceof Error) {
        const name = error.name && error.name !== "Error" ? `${error.name}: ` : "";
        return `${name}${error.message || String(error)}`;
      }
      if (typeof error === "object") {
        try {
          return JSON.stringify(error);
        } catch (_err) {
          return String(error);
        }
      }
      return String(error);
    }

    function truncateTextForDebug(text, maxLength = 90) {
      if (typeof text !== "string") {
        return "";
      }
      return text.length > maxLength ? `${text.slice(0, maxLength - 1)}‚Ä¶` : text;
    }

    function updateDebugVisibility() {
      if (!debugPanel || !debugLog) return;
      const shouldShow = Boolean(debugToggle && debugToggle.checked);
      debugPanel.hidden = !shouldShow;
      if (shouldShow) {
        debugLog.textContent = debugEntries.join("\n\n");
      }
    }

    function buildInstructionSpeech(ex) {
      if (!ex) return "";
      const name = (ex.name || "").trim();
      const instruction = (ex.instruction || "").trim();
      if (!instruction) return name;
      if (name && instruction.toLowerCase().startsWith(name.toLowerCase())) {
        return instruction;
      }
      return name ? `${name}. ${instruction}` : instruction;
    }

    updateDebugVisibility();
    if (debugToggle) {
      debugToggle.addEventListener("change", updateDebugVisibility);
    }

    function base64ToBlob(base64, mimeType = "audio/mpeg") {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType });
    }

    function cancelActiveSpeech() {
      if (currentFetchController) {
        currentFetchController.abort();
        currentFetchController = null;
      }
      if (currentAudio) {
        currentAudio.pause();
      }
      if (hasBrowserSpeech) {
        speechSynthesis.cancel();
      }
      skipBtn.disabled = true;
    }

    async function callSpeechApi(text, { signal } = {}) {
      const payload = { text, language: "de-DE" };
      if (preferredVoice) {
        payload.voice = preferredVoice;
      }

      const response = await fetch(SPEECH_API_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal,
      });

      const contentType = response.headers.get("content-type") || "";

      if (!response.ok) {
        let errorMessage = `Speech API Fehler (${response.status})`;
        if (contentType.includes("application/json")) {
          try {
            const data = await response.json();
            if (data && data.error) {
              errorMessage = data.error;
            }
          } catch (_err) {
            // ignore JSON parsing error
          }
        } else {
          const textMessage = await response.text();
          if (textMessage) {
            errorMessage = textMessage;
          }
        }
        throw new Error(errorMessage);
      }

      if (contentType.includes("application/json")) {
        const data = await response.json();
        if (data && data.audioUrl) {
          const audioResponse = await fetch(data.audioUrl, { signal });
          if (!audioResponse.ok) {
            throw new Error(`Konnte Audio-URL nicht laden (${audioResponse.status}).`);
          }
          return await audioResponse.blob();
        }
        if (data && data.audioBase64) {
          return base64ToBlob(data.audioBase64, data.mimeType || "audio/mpeg");
        }
        if (data && data.error) {
          throw new Error(data.error);
        }
        throw new Error("Unerwartete Antwort der Speech API.");
      }

      return await response.blob();
    }

    async function playRemoteAudio(text) {
      const controller = new AbortController();
      currentFetchController = controller;

      let blob;
      try {
        blob = await callSpeechApi(text, { signal: controller.signal });
      } catch (error) {
        const abortedFetch =
          controller.signal.aborted ||
          skipRequested ||
          aborted ||
          (error && error.name === "AbortError");
        if (abortedFetch) {
          skipBtn.disabled = true;
          return;
        }
        throw error;
      } finally {
        if (currentFetchController === controller) {
          currentFetchController = null;
        }
      }

      if (aborted || skipRequested) {
        skipBtn.disabled = true;
        return;
      }

      const objectUrl = URL.createObjectURL(blob);
      currentAudioUrl = objectUrl;
      const audio = sharedAudioElement ?? new Audio();
      if (!sharedAudioElement) {
        audio.playsInline = true;
        audio.preload = "auto";
      } else {
        try {
          sharedAudioElement.pause();
        } catch (_err) {
          // ignore pause errors
        }
      }
      audio.muted = false;
      audio.src = objectUrl;
      try {
        audio.currentTime = 0;
      } catch (_err) {
        // ignore time reset errors
      }
      try {
        audio.load();
      } catch (_err) {
        // ignore load errors
      }
      currentAudio = audio;
      skipBtn.disabled = false;

      await new Promise((resolve, reject) => {
        let settled = false;

        function cleanup() {
          audio.removeEventListener("ended", onEnded);
          audio.removeEventListener("pause", onPause);
          audio.removeEventListener("error", onError);

          if (currentAudio === audio) {
            currentAudio = null;
          }
          if (currentAudioUrl === objectUrl) {
            URL.revokeObjectURL(objectUrl);
            currentAudioUrl = null;
          }
          skipBtn.disabled = true;
          try {
            audio.pause();
          } catch (_err) {
            // ignore pause errors
          }
          if (audio === sharedAudioElement) {
            try {
              audio.removeAttribute("src");
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          } else {
            try {
              audio.src = "";
              audio.load();
            } catch (_err) {
              // ignore cleanup errors
            }
          }
        }

        function finish() {
          if (settled) return;
          settled = true;
          cleanup();
          resolve();
        }

        function fail(err) {
          if (settled) return;
          settled = true;
          cleanup();
          reject(err);
        }

        const onEnded = () => finish();
        const onPause = () => {
          if (!audio.ended) {
            finish();
          }
        };
        const onError = event => {
          const error = event instanceof Event && audio.error ? audio.error : null;
          fail(error || new Error("Audio playback failed"));
        };

        audio.addEventListener("ended", onEnded);
        audio.addEventListener("pause", onPause);
        audio.addEventListener("error", onError);

        audio.play().catch(err => {
          if (err && err.name === "NotAllowedError") {
            audioUnlocked = false;
            audioUnlockPromise = null;
            setStatus(
              "Browser blockiert die Audiowiedergabe. Tippe erneut, um sie zu aktivieren.",
              "warn"
            );
            appendDebug(
              "Audiowiedergabe durch den Browser blockiert.",
              describeError(err)
            );
          }
          fail(err);
        });
      });
    }

    function speakWithLocalSynthesis(text) {
      return new Promise(resolve => {
        if (!hasBrowserSpeech) {
          setStatus("Sprachsynthese im Browser nicht verf√ºgbar.", "error");
          appendDebug("Lokale Sprachsynthese des Browsers nicht verf√ºgbar.");
          resolve();
          return;
        }

        skipBtn.disabled = false;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "de-DE";
        utterance.rate = 1;

        let finished = false;
        const cancelWatcher = setInterval(() => {
          if (skipRequested || aborted) {
            speechSynthesis.cancel();
          }
        }, 100);

        let guardTimer = null;

        const cleanup = () => {
          clearInterval(cancelWatcher);
          if (guardTimer) {
            clearTimeout(guardTimer);
            guardTimer = null;
          }
          skipBtn.disabled = true;
        };

        const finish = () => {
          if (finished) return;
          finished = true;
          cleanup();
          resolve();
        };

        const scheduleGuard = () => {
          guardTimer = setTimeout(() => {
            if (speechSynthesis.speaking || speechSynthesis.pending) {
              scheduleGuard();
              return;
            }
            console.warn("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            appendDebug("Lokale Sprachsynthese reagiert nicht, fahre ohne Audio fort.");
            finish();
          }, 4000);
        };

        utterance.onend = () => finish();

        utterance.onerror = () => finish();

        speechSynthesis.cancel();
        scheduleGuard();
        speechSynthesis.speak(utterance);
      });
    }

    function getAudioContextConstructor() {
      return typeof window !== "undefined"
        ? window.AudioContext || window.webkitAudioContext || null
        : null;
    }

    async function unlockAudioContext() {
      const AudioContextCtor = getAudioContextConstructor();
      if (!AudioContextCtor) {
        lastAudioUnlockError = "Keine Web-Audio-Unterst√ºtzung zur Tonfreigabe vorhanden.";
        return false;
      }

      if (audioContextUnlockPromise) {
        return audioContextUnlockPromise;
      }

      const attempt = (async () => {
        try {
          if (!sharedAudioContext) {
            sharedAudioContext = new AudioContextCtor();
          }
          const context = sharedAudioContext;
          if (!context) {
            return false;
          }
          if (context.state === "suspended") {
            await context.resume();
          }

          const frameCount = Math.max(Math.floor(context.sampleRate / 60), 1);
          const buffer = context.createBuffer(1, frameCount, context.sampleRate);
          const source = context.createBufferSource();
          source.buffer = buffer;
          source.connect(context.destination);
          try {
            source.start(0);
          } catch (_err) {
            // ignore start errors if source already stopped
          }
          return true;
        } catch (error) {
          appendDebug("Freischaltung via Web Audio fehlgeschlagen.", describeError(error));
          lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden (Web Audio).";
          return false;
        }
      })();

      audioContextUnlockPromise = attempt
        .then(success => {
          if (!success) {
            audioContextUnlockPromise = null;
          }
          return success;
        })
        .catch(error => {
          audioContextUnlockPromise = null;
          throw error;
        });

      return audioContextUnlockPromise;
    }

    function ensureAudioUnlocked() {
      if (audioUnlockPromise) return audioUnlockPromise;

      if (typeof Audio === "undefined") {
        audioUnlocked = true;
        lastAudioUnlockError = "";
        audioUnlockPromise = Promise.resolve(true);
        return audioUnlockPromise;
      }

      if (!sharedAudioElement) {
        sharedAudioElement = new Audio();
        sharedAudioElement.preload = "auto";
        sharedAudioElement.playsInline = true;
      }

      sharedAudioElement.muted = true;
      sharedAudioElement.src = SILENT_AUDIO_SRC;

      const unlockAttempt = sharedAudioElement
        .play()
        .then(() => true)
        .catch(async err => {
          console.warn("Konnte Audio nicht initialisieren.", err);
          const errorDescription = describeError(err);
          const isNotSupported = err && err.name === "NotSupportedError";
          const isNotAllowed = err && err.name === "NotAllowedError";

          if (isNotSupported) {
            appendDebug(
              "Stille Audiodatei zum Entsperren wird nicht unterst√ºtzt.",
              errorDescription
            );
            lastAudioUnlockError =
              "Browser unterst√ºtzt das Audioformat zur Freischaltung nicht.";
            const contextUnlocked = await unlockAudioContext();
            if (contextUnlocked) {
              lastAudioUnlockError = "";
              return true;
            }
          } else if (isNotAllowed) {
            appendDebug("Browser blockiert die Audiowiedergabe.", errorDescription);
            lastAudioUnlockError =
              "Browser blockiert die Audiowiedergabe. Bitte tippe erneut, um Ton zu aktivieren.";
          } else {
            appendDebug("Audio konnte nicht freigeschaltet werden.", errorDescription);
            lastAudioUnlockError = "Audio konnte nicht freigeschaltet werden.";
          }
          return false;
        })
        .finally(() => {
          try {
            sharedAudioElement.pause();
            sharedAudioElement.currentTime = 0;
            sharedAudioElement.removeAttribute("src");
            sharedAudioElement.load();
          } catch (_err) {
            // ignore cleanup errors
          }
          sharedAudioElement.muted = false;
        });

      audioUnlockPromise = unlockAttempt.then(success => {
        audioUnlocked = success;
        if (!success) {
          audioUnlockPromise = null;
        }
        return success;
      });

      return audioUnlockPromise;
    }

    const userActivationEvents = ["pointerdown", "touchstart", "keydown"];
    userActivationEvents.forEach(eventName => {
      window.addEventListener(
        eventName,
        () => {
          if (!audioUnlocked) {
            ensureAudioUnlocked();
          }
        },
        { once: true, capture: true }
      );
    });

    async function speak(text) {
      if (aborted) return;

      skipRequested = false;

      const attemptStart = now();
      const truncatedText = truncateTextForDebug(text);
      const canUseRemote = !remoteBackoffActive || now() >= remoteRetryAvailableAt;

      if (canUseRemote) {
        try {
          await playRemoteAudio(text);
          const duration = Math.round(now() - attemptStart);
          if (duration > REMOTE_SPEECH_SLOW_THRESHOLD_MS && truncatedText) {
            appendDebug(
              `Online-Sprachsynthese ben√∂tigte ${duration} ms f√ºr eine Antwort.`,
              `Text: "${truncatedText}"`
            );
          }
          if (remoteFailureNotified) {
            if (truncatedText) {
              appendDebug(
                "Online-Sprachsynthese wieder verf√ºgbar.",
                `Text: "${truncatedText}"`
              );
            } else {
              appendDebug("Online-Sprachsynthese wieder verf√ºgbar.");
            }
            setStatus("");
            remoteFailureNotified = false;
          }
          remoteFailureCount = 0;
          remoteBackoffActive = false;
          remoteRetryAvailableAt = 0;
          lastRemoteBackoffLogAt = 0;
          return;
        } catch (error) {
          if (aborted || skipRequested || (error && error.name === "AbortError")) {
            return;
          }
          const duration = Math.round(now() - attemptStart);
          console.warn("Speech API nicht erreichbar, nutze Fallback.", error);
          const details = [
            `Grund: ${describeError(error)}`,
            truncatedText ? `Text: "${truncatedText}"` : "",
          ]
            .filter(Boolean)
            .join("\n");
          appendDebug(
            `Online-Sprachsynthese fehlgeschlagen nach ${duration} ms.`,
            details
          );
          if (!remoteFailureNotified) {
            setStatus(
              "Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.",
              "warn"
            );
            remoteFailureNotified = true;
          }
          remoteFailureCount = Math.min(remoteFailureCount + 1, 6);
          const backoffExponent = Math.max(remoteFailureCount - 1, 0);
          const backoffDelay = Math.min(
            REMOTE_RETRY_BASE_DELAY_MS * Math.pow(2, backoffExponent),
            REMOTE_RETRY_MAX_DELAY_MS
          );
          remoteRetryAvailableAt = now() + backoffDelay;
          remoteBackoffActive = true;
          lastRemoteBackoffLogAt = 0;
          const backoffSeconds = Math.max(1, Math.round(backoffDelay / 1000));
          appendDebug(`Online-Sprachsynthese pausiert f√ºr ${backoffSeconds} s.`);
          skipRequested = false;
          if (truncatedText) {
            appendDebug(
              "Wechsle auf lokale Sprachsynthese.",
              `Text: "${truncatedText}"`
            );
          } else {
            appendDebug("Wechsle auf lokale Sprachsynthese.");
          }
          await speakWithLocalSynthesis(text);
          return;
        }
      }

      if (!remoteFailureNotified) {
        setStatus("Online-Sprachsynthese nicht verf√ºgbar ‚Äì lokale Stimme wird genutzt.", "warn");
        remoteFailureNotified = true;
      }

      if (remoteBackoffActive) {
        const remainingMs = Math.max(remoteRetryAvailableAt - now(), 0);
        if (!lastRemoteBackoffLogAt || now() - lastRemoteBackoffLogAt >= REMOTE_BACKOFF_LOG_THROTTLE_MS) {
          const secondsRemaining = Math.max(1, Math.ceil(remainingMs / 1000));
          const logMessage = `√úberspringe Online-Sprachsynthese (noch ${secondsRemaining} s Auszeit).`;
          const details = truncatedText ? `Text: "${truncatedText}"` : "";
          appendDebug(logMessage, details);
          lastRemoteBackoffLogAt = now();
        }
      }

      skipRequested = false;
      await speakWithLocalSynthesis(text);
      return;
    }

    // --- √úbungen laden ---
    fetch("exercises.json")
      .then(res => res.json())
      .then(data => {
        exercises = data;
        select.innerHTML = data.map(e => `<option value="${e.id}">${e.name}</option>`).join("");
        exercise = exercises[0] ?? null;
        if (exercise) {
          const preview = buildInstructionSpeech(exercise);
          display.textContent = preview || exercise.name;
        }
        startBtn.disabled = exercises.length === 0;
      })
      .catch(err => {
        console.error("Fehler beim Laden der √úbungen", err);
        select.innerHTML = "<option>Fehler beim Laden</option>";
        setStatus("√úbungen konnten nicht geladen werden.", "error");
      });

    countdownStepSelect.innerHTML = Array.from(
      { length: Math.floor((COUNTDOWN_MAX_MS - COUNTDOWN_MIN_MS) / COUNTDOWN_STEP_INCREMENT_MS) + 1 },
      (_, idx) => {
        const value = COUNTDOWN_MIN_MS + idx * COUNTDOWN_STEP_INCREMENT_MS;
        const selected = value === countdownStepMs ? " selected" : "";
        return `<option value="${value}"${selected}>${value} ms</option>`;
      }
    ).join("");

    // --- Countdown ---
    async function countdown(seconds, label = "", finalCue = "") {
      for (let i = seconds; i > 0; i--) {
        if (aborted) return;
        display.textContent = `${label}${label ? " " : ""}${i}`;
        await speak(i.toString());
        await new Promise(r => setTimeout(r, countdownStepMs));
      }
      if (finalCue) {
        display.textContent = finalCue;
        await speak(finalCue);
      }
    }

    async function runRepTimer(seconds) {
      const totalDurationMs = Math.max(0, seconds * 1000);
      if (totalDurationMs <= 0) {
        return;
      }
      if (!repProgressContainer || !repProgressBar) {
        await new Promise(r => setTimeout(r, totalDurationMs));
        return;
      }

      repProgressContainer.hidden = false;
      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      void repProgressBar.offsetWidth; // Force reflow to restart transition
      repProgressBar.style.transition = "width 0.25s ease";

      const steps = Math.max(1, Math.round(seconds));
      const finalStepDuration = Math.max(totalDurationMs - (steps - 1) * 1000, 0);

      for (let step = 1; step <= steps; step++) {
        if (aborted) break;
        const waitMs = step === steps ? finalStepDuration || 1000 : 1000;
        if (waitMs > 0) {
          await new Promise(r => setTimeout(r, waitMs));
        }
        if (aborted) break;
        const progress = Math.min((step / steps) * 100, 100);
        repProgressBar.style.width = `${progress}%`;
      }

      if (!aborted) {
        await new Promise(r => setTimeout(r, 150));
      }

      repProgressBar.style.transition = "none";
      repProgressBar.style.width = "0%";
      repProgressContainer.hidden = true;
    }

    // --- Satz ---
    async function runSet(setNr, withPrep) {
      if (aborted) return;
      if (withPrep) {
        display.textContent = `Vorbereitung (Satz ${setNr})...`;
        await speak(`${exercise.prep_time} Sekunden Countdown`);
        await countdown(exercise.prep_time, "", "Los!");
      } else {
        await speak("Weiter mit dem n√§chsten Satz. Los!");
      }

      for (let i = 1; i <= exercise.duration && !aborted; i++) {
        display.textContent = `Wiederholung ${i}`;
        await runRepTimer(exercise.rep_time);
        if (aborted) break;
        await speak(i.toString());
      }

      if (!aborted) {
        display.textContent = `Satz ${setNr} beendet!`;
        await speak(`Satz ${setNr} beendet.`);
      }
    }

    // --- Training ---
    async function doExercise() {
      aborted = false;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      if (!remoteFailureNotified) {
        setStatus("");
      }

      if (repProgressContainer && repProgressBar) {
        repProgressBar.style.width = "0%";
        repProgressContainer.hidden = true;
      }

      const instructionSpeech = buildInstructionSpeech(exercise);
      if (instructionSpeech) {
        display.textContent = instructionSpeech;
      } else if (exercise && exercise.name) {
        display.textContent = exercise.name;
      }
      await speak(`Pro √úbungsdurchf√ºhrung sind ${exercise.rep_time} Sekunden geplant.`);
      if (instructionSpeech) {
        await speak(instructionSpeech);
      }

      for (let set = 1; set <= exercise.sets && !aborted; set++) {
        const withPrep = (set === 1);
        await runSet(set, withPrep);
        if (aborted) break;

        if (set < exercise.sets) {
          await speak(`Pause ${exercise.rest_time} Sekunden.`);
          display.textContent = `Pause: ${exercise.rest_time}s`;
          await new Promise(r => setTimeout(r, (exercise.rest_time - 5) * 1000));
          if (aborted) break;
          await speak("Noch f√ºnf Sekunden");
          await countdown(5, "", ""); // kein Los! hier
        }
      }

      if (!aborted) {
        display.textContent = "Fertig! Gut gemacht üéâ";
        await speak("Fertig! Gut gemacht.");
      } else {
        display.textContent = "Abgebrochen.";
        await speak("Training abgebrochen.");
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;
    }

    // --- Events ---
    select.addEventListener("change", () => {
      const id = select.value;
      exercise = exercises.find(e => e.id === id) ?? null;
      if (exercise) {
        const preview = buildInstructionSpeech(exercise);
        display.textContent = preview || exercise.name;
      }
    });

    startBtn.addEventListener("click", async () => {
      exercise = exercises.find(e => e.id === select.value) ?? null;
      if (!exercise) return;
      const unlocked = await ensureAudioUnlocked();
      if (!unlocked) {
        const warningMessage =
          lastAudioUnlockError ||
          "Audioausgabe wurde vom Browser blockiert. Bitte tippe erneut oder pr√ºfe die Autoplay-Einstellungen.";
        setStatus(warningMessage, "warn");
        appendDebug(
          "Audio konnte nicht freigeschaltet werden.",
          lastAudioUnlockError ? truncateTextForDebug(lastAudioUnlockError, 200) : ""
        );
        return;
      }
      lastAudioUnlockError = "";
      void doExercise();
    });

    skipBtn.addEventListener("click", () => {
      if (skipBtn.disabled) return;
      skipRequested = true;
      if (currentFetchController) {
        currentFetchController.abort();
      }
      if (currentAudio) {
        currentAudio.pause();
      } else if (hasBrowserSpeech) {
        speechSynthesis.cancel();
      }
      skipBtn.disabled = true;
    });
    countdownStepSelect.addEventListener("change", () => {
      countdownStepMs = Number(countdownStepSelect.value);
    });
    stopBtn.addEventListener("click", () => {
      aborted = true;
      skipRequested = false;
      cancelActiveSpeech();
      display.textContent = "Abbruch...";
      startBtn.disabled = false;
      stopBtn.disabled = true;
      remoteFailureNotified = false;
      setStatus("Training gestoppt.", "info");
      if (repProgressContainer && repProgressBar) {
        repProgressBar.style.transition = "none";
        repProgressBar.style.width = "0%";
        repProgressContainer.hidden = true;
      }
    });

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./service-worker.js")
          .catch(err => console.error("Service Worker registration failed", err));
      });
    }
  </script>
</body>
</html>
